{"ast":null,"code":"import { isNil, last, dropLast as dropLast$2, adjust, compose } from '@react-pdf/fns';\nimport _extends from '@babel/runtime/helpers/extends';\nimport _objectWithoutPropertiesLoose from '@babel/runtime/helpers/objectWithoutPropertiesLoose';\nimport _createForOfIteratorHelperLoose from '@babel/runtime/helpers/createForOfIteratorHelperLoose';\nimport unicode from 'unicode-properties';\nimport hyphen from 'hyphen';\nimport pattern from 'hyphen/patterns/en-us';\n/**\n * Create attributed string from text fragments\n *\n * @param  {Array}  fragments\n * @return {Object} attributed string\n */\n\nvar fromFragments = function fromFragments(fragments) {\n  var offset = 0;\n  var string = '';\n  var runs = [];\n  fragments.forEach(function (fragment) {\n    string += fragment.string;\n    runs.push({\n      start: offset,\n      end: offset + fragment.string.length,\n      attributes: fragment.attributes || {}\n    });\n    offset += fragment.string.length;\n  });\n  return {\n    string: string,\n    runs: runs\n  };\n};\n/**\n * Default word hyphenation engine used when no one provided.\n * Does not perform word hyphenation at all\n *\n * @param  {String} word\n * @return {Array} same word\n */\n\n\nvar defaultHyphenationEngine = function defaultHyphenationEngine(word) {\n  return [word];\n};\n/**\n * Wrap words of attribute string\n *\n * @param  {Object} layout engines\n * @param  {Object}  layout options\n * @param  {Object}  attributed string\n * @return {Object} attributed string including syllables\n */\n\n\nvar wrapWords = function wrapWords(engines, options) {\n  if (engines === void 0) {\n    engines = {};\n  }\n\n  if (options === void 0) {\n    options = {};\n  }\n\n  return function (attributedString) {\n    var _engines$wordHyphenat, _engines;\n\n    var syllables = [];\n    var fragments = [];\n    var hyphenateWord = options.hyphenationCallback || ((_engines$wordHyphenat = (_engines = engines).wordHyphenation) === null || _engines$wordHyphenat === void 0 ? void 0 : _engines$wordHyphenat.call(_engines, options)) || defaultHyphenationEngine;\n\n    for (var i = 0; i < attributedString.runs.length; i += 1) {\n      var string = '';\n      var run = attributedString.runs[i];\n      var words = attributedString.string.slice(run.start, run.end).split(/([ ]+)/g).filter(Boolean);\n\n      for (var j = 0; j < words.length; j += 1) {\n        var word = words[j];\n        var parts = hyphenateWord(word);\n        syllables.push.apply(syllables, parts);\n        string += parts.join('');\n      }\n\n      fragments.push({\n        string: string,\n        attributes: run.attributes\n      });\n    }\n\n    return _extends({}, fromFragments(fragments), {\n      syllables: syllables\n    });\n  };\n};\n/**\n * Clone rect\n *\n * @param  {Object}  rect\n * @return {Object} cloned rect\n */\n\n\nvar copy = function copy(rect) {\n  return Object.assign({}, rect);\n};\n\nvar partition = function partition(rect, height) {\n  var a = Object.assign({}, rect, {\n    height: height\n  });\n  var b = Object.assign({}, rect, {\n    y: rect.y + height,\n    height: rect.height - height\n  });\n  return [a, b];\n};\n/**\n * Crop upper section of rect\n *\n * @param  {Object}  rect\n * @return {Object} cropped rect\n */\n\n\nvar crop = function crop(height, rect) {\n  var _partition = partition(rect, height),\n      result = _partition[1];\n\n  return result;\n};\n/**\n * Get paragraph block height\n *\n * @param  {Object}  paragraph block\n * @return {number} paragraph block height\n */\n\n\nvar height$2 = function height(paragraph) {\n  return paragraph.reduce(function (acc, block) {\n    return acc + block.box.height;\n  }, 0);\n};\n/**\n * Calculate run scale\n *\n * @param  {Object}  run\n * @return {number} scale\n */\n\n\nvar calculateScale = function calculateScale(run) {\n  var _attributes$font;\n\n  var attributes = run.attributes || {};\n  var fontSize = attributes.fontSize || 12;\n  var unitsPerEm = (_attributes$font = attributes.font) === null || _attributes$font === void 0 ? void 0 : _attributes$font.unitsPerEm;\n  return unitsPerEm ? fontSize / unitsPerEm : 0;\n};\n/**\n * Get run scale\n *\n * @param  {Object}  run\n * @return {number} scale\n */\n\n\nvar scale = function scale(run) {\n  var _run$attributes;\n\n  return ((_run$attributes = run.attributes) === null || _run$attributes === void 0 ? void 0 : _run$attributes.scale) || calculateScale(run);\n};\n/**\n * Get ligature offset by index\n *\n * Ex. ffi ligature\n *\n *   glyphs:         l  o  f  f  i  m\n *   glyphIndices:   0  1  2  2  2  3\n *   offset:         0  0  0  1  2  0\n *\n * @param  {number}  index\n * @param  {Object}  run\n * @return {number} ligature offset\n */\n\n\nvar offset = function offset(index, run) {\n  if (!run) return 0;\n  var glyphIndices = run.glyphIndices || [];\n  var value = glyphIndices[index];\n  return glyphIndices.slice(0, index).filter(function (i) {\n    return i === value;\n  }).length;\n};\n/**\n * Get run font\n *\n * @param  {Object}  run\n * @return {Object} font\n */\n\n\nvar getFont = function getFont(run) {\n  var _run$attributes;\n\n  return ((_run$attributes = run.attributes) === null || _run$attributes === void 0 ? void 0 : _run$attributes.font) || null;\n};\n/**\n * Slice glyph between codePoints range\n * Util for breaking ligatures\n *\n * @param  {number}  start code point index\n * @param  {number}  end code point index\n * @param  {Object}  font to generate new glyph\n * @param  {Object} glyph to be sliced\n * @return {Array} sliced glyph parts\n */\n\n\nvar slice$2 = function slice(start, end, font, glyph) {\n  if (!glyph) return [];\n  if (start === end) return [];\n  if (start === 0 && end === glyph.codePoints.length) return [glyph];\n  var codePoints = glyph.codePoints.slice(start, end);\n  var string = String.fromCodePoint.apply(String, codePoints);\n  return font ? font.layout(string).glyphs : [glyph];\n};\n/**\n * Return glyph index at string index, if glyph indices present.\n * Otherwise return string index\n *\n * @param  {number}  string index\n * @param  {Object}  run\n * @return {number}  glyph index\n */\n\n\nvar glyphIndexAt = function glyphIndexAt(index, run) {\n  var _run$glyphIndices;\n\n  var result = run === null || run === void 0 ? void 0 : (_run$glyphIndices = run.glyphIndices) === null || _run$glyphIndices === void 0 ? void 0 : _run$glyphIndices[index];\n  return isNil(result) ? index : result;\n};\n/**\n * Returns new array starting with zero, and keeping same relation between consecutive values\n *\n * @param  {Array[number]}  list\n * @return {boolean} normalized array\n */\n\n\nvar normalize = function normalize(array) {\n  var head = array[0];\n  return array.map(function (value) {\n    return value - head;\n  });\n};\n/**\n * Slice run between glyph indices range\n *\n * @param  {number}  start glyph index\n * @param  {number}  end glyph index\n * @param  {Object}  run\n * @return {Object} sliced run\n */\n\n\nvar slice$1 = function slice(start, end, run) {\n  var _run$glyphs, _run$glyphs2;\n\n  var runScale = scale(run);\n  var font = getFont(run); // Get glyph start and end indices\n\n  var startIndex = glyphIndexAt(start, run);\n  var endIndex = glyphIndexAt(end, run); // Get start and end glyph\n\n  var startGlyph = (_run$glyphs = run.glyphs) === null || _run$glyphs === void 0 ? void 0 : _run$glyphs[startIndex];\n  var endGlyph = (_run$glyphs2 = run.glyphs) === null || _run$glyphs2 === void 0 ? void 0 : _run$glyphs2[endIndex]; // Get start ligature chunks (if any)\n\n  var startOffset = offset(start, run);\n  var startGlyphs = startOffset > 0 ? slice$2(startOffset, Infinity, font, startGlyph) : []; // Get end ligature chunks (if any)\n\n  var endOffset = offset(end, run);\n  var endGlyphs = slice$2(0, endOffset, font, endGlyph); // Compute new glyphs\n\n  var sliceStart = startIndex + Math.min(1, startOffset);\n  var glyphs = (run.glyphs || []).slice(sliceStart, endIndex); // Compute new positions\n\n  var glyphPosition = function glyphPosition(g) {\n    return {\n      xAdvance: g.advanceWidth * runScale\n    };\n  };\n\n  var startPositions = startGlyphs.map(glyphPosition);\n  var positions = (run.positions || []).slice(sliceStart, endIndex);\n  var endPositions = endGlyphs.map(glyphPosition);\n  return Object.assign({}, run, {\n    start: run.start + start,\n    end: Math.min(run.end, run.start + end),\n    glyphIndices: normalize((run.glyphIndices || []).slice(start, end)),\n    glyphs: [startGlyphs, glyphs, endGlyphs].flat(),\n    positions: [startPositions, positions, endPositions].flat()\n  });\n};\n/**\n * Get run index that contains passed index\n *\n * @param  {number}  char index\n * @param  {Array}  runs array\n * @return {Array} run index\n */\n\n\nvar runIndexAt$1 = function runIndexAt(n, runs) {\n  if (!runs) return -1;\n  return runs.findIndex(function (run) {\n    return run.start <= n && n < run.end;\n  });\n};\n/**\n * Filter runs contained between start and end\n *\n * @param  {number}  start\n * @param  {number}  end\n * @param  {Array}  runs\n * @return {boolean} filtered runs\n */\n\n\nvar filter = function filter(start, end, runs) {\n  var startIndex = runIndexAt$1(start, runs);\n  var endIndex = Math.max(runIndexAt$1(end - 1, runs), startIndex);\n  return runs.slice(startIndex, endIndex + 1);\n};\n/**\n * Subtract scalar to run\n *\n * @param  {number}  scalar\n * @param  {Object}  run\n * @return {Object} subtracted run\n */\n\n\nvar subtract = function subtract(n, run) {\n  var start = run.start - n;\n  var end = run.end - n;\n  return Object.assign({}, run, {\n    start: start,\n    end: end\n  });\n};\n/**\n * Slice array of runs\n *\n * @param  {number}  start offset\n * @param  {number}  end offset\n * @param  {Array}  runs\n * @return {Array} sliced runs\n */\n\n\nvar sliceRuns = function sliceRuns(start, end, runs) {\n  var sliceFirstRun = function sliceFirstRun(a) {\n    return slice$1(start - a.start, end - a.start, a);\n  };\n\n  var sliceLastRun = function sliceLastRun(a) {\n    return slice$1(0, end - a.start, a);\n  };\n\n  return runs.map(function (run, i) {\n    var result = run;\n    var isFirst = i === 0;\n    var isLast = !isFirst && i === runs.length - 1;\n    if (isFirst) result = sliceFirstRun(run);\n    if (isLast) result = sliceLastRun(run);\n    return subtract(start, result);\n  });\n};\n/**\n * Slice attributed string between two indices\n *\n * @param  {number}  start offset\n * @param  {number}  end offset\n * @param  {Object}  attributedString\n * @return {Object} attributedString\n */\n\n\nvar slice = function slice(start, end, attributedString) {\n  if (attributedString.string.length === 0) return attributedString;\n  var string = attributedString.string.slice(start, end);\n  var filteredRuns = filter(start, end, attributedString.runs);\n  var slicedRuns = sliceRuns(start, end, filteredRuns);\n  return Object.assign({}, attributedString, {\n    string: string,\n    runs: slicedRuns\n  });\n};\n\nvar findCharIndex = function findCharIndex(string) {\n  return string.search(/\\S/g);\n};\n\nvar findLastCharIndex = function findLastCharIndex(string) {\n  var match = string.match(/\\S/g);\n  return match ? string.lastIndexOf(match[match.length - 1]) : -1;\n};\n/**\n * Removes (strips) whitespace from both ends of the attributted string.\n *\n * @param  {Object}  attributedString\n * @return {Object} attributedString\n */\n\n\nvar trim = function trim(attributedString) {\n  var start = findCharIndex(attributedString.string);\n  var end = findLastCharIndex(attributedString.string);\n  return slice(start, end + 1, attributedString);\n};\n/**\n * Returns empty run\n *\n * @return {Object} empty run\n */\n\n\nvar empty$1 = function empty() {\n  return {\n    start: 0,\n    end: 0,\n    glyphIndices: [],\n    glyphs: [],\n    positions: [],\n    attributes: {}\n  };\n};\n\nvar isNumber = function isNumber(value) {\n  return typeof value === 'number';\n};\n/**\n * Append glyph indices with given length\n *\n * Ex. appendIndices(3, [0, 1, 2, 2]) => [0, 1, 2, 2, 3, 3, 3]\n *\n * @param  {number}  length\n * @param  {Array}  glyph indices\n * @return {Array}  extended glyph indices\n */\n\n\nvar appendIndices = function appendIndices(length, indices) {\n  var lastIndex = last(indices);\n  var value = isNil(lastIndex) ? 0 : lastIndex + 1;\n  var newIndices = Array(length).fill(value);\n  return indices.concat(newIndices);\n};\n/**\n * Get glyph for a given code point\n *\n * @param  {number}  codePoint\n * @param  {Object}  font\n * @return {Object}  glyph\n * */\n\n\nvar fromCodePoint = function fromCodePoint(value, font) {\n  return font && value ? font.glyphForCodePoint(value) : null;\n};\n/**\n * Append glyph to run\n *\n * @param  {Object}  glyph\n * @param  {Object}  run\n * @return {Object} run with glyph\n */\n\n\nvar appendGlyph = function appendGlyph(glyph, run) {\n  var _glyph$codePoints;\n\n  var glyphLength = ((_glyph$codePoints = glyph.codePoints) === null || _glyph$codePoints === void 0 ? void 0 : _glyph$codePoints.length) || 0;\n  var end = run.end + glyphLength;\n  var glyphs = run.glyphs.concat(glyph);\n  var glyphIndices = appendIndices(glyphLength, run.glyphIndices);\n  if (!run.positions) return Object.assign({}, run, {\n    end: end,\n    glyphs: glyphs,\n    glyphIndices: glyphIndices\n  });\n  var positions = run.positions.concat({\n    xAdvance: glyph.advanceWidth * scale(run)\n  });\n  return Object.assign({}, run, {\n    end: end,\n    glyphs: glyphs,\n    glyphIndices: glyphIndices,\n    positions: positions\n  });\n};\n/**\n * Append glyph or code point to run\n *\n * @param  {Object | number}  glyph | codePoint\n * @param  {Object}  run\n * @return {Object} run with glyph\n */\n\n\nvar append$1 = function append(value, run) {\n  if (!value) return run;\n  var font = getFont(run);\n  var glyph = isNumber(value) ? fromCodePoint(value, font) : value;\n  return appendGlyph(glyph, run);\n};\n/**\n * Get string from array of code points\n *\n * @param {Array} code points\n * @return {String} string\n */\n\n\nvar stringFromCodePoints = function stringFromCodePoints(codePoints) {\n  return String.fromCodePoint.apply(String, codePoints);\n};\n/**\n * Append glyph into last run of attributed string\n *\n * @param {Object} glyph\n * @param {Object} attributed string\n * @return {Object} attributed string with new glyph\n */\n\n\nvar append = function append(glyph, attributedString) {\n  var codePoints = (glyph === null || glyph === void 0 ? void 0 : glyph.codePoints) || [];\n  var codePointsString = stringFromCodePoints(codePoints);\n  var string = attributedString.string + codePointsString;\n  var firstRuns = attributedString.runs.slice(0, -1);\n  var lastRun = last(attributedString.runs) || empty$1();\n  var runs = firstRuns.concat(append$1(glyph, lastRun));\n  return Object.assign({}, attributedString, {\n    string: string,\n    runs: runs\n  });\n};\n\nvar ELLIPSIS_UNICODE = 8230;\nvar ELLIPSIS_STRING = String.fromCharCode(ELLIPSIS_UNICODE);\n/**\n * Get ellipsis codepoint. This may be different in standard and embedded fonts\n *\n * @param  {number}  font\n * @return {Object} ellipsis codepoint\n */\n\nvar getEllipsisCodePoint = function getEllipsisCodePoint(font) {\n  if (!font.encode) return ELLIPSIS_UNICODE;\n\n  var _font$encode = font.encode(ELLIPSIS_STRING),\n      codePoints = _font$encode[0];\n\n  return parseInt(codePoints[0], 16);\n};\n/**\n * Trucante block with ellipsis\n *\n * @param  {number}  lines quantity\n * @param  {Object}  paragraph block\n * @return {Object} sliced paragraph block\n */\n\n\nvar truncate = function truncate(block) {\n  var _last, _last2, _last2$attributes;\n\n  var runs = ((_last = last(block)) === null || _last === void 0 ? void 0 : _last.runs) || [];\n  var font = (_last2 = last(runs)) === null || _last2 === void 0 ? void 0 : (_last2$attributes = _last2.attributes) === null || _last2$attributes === void 0 ? void 0 : _last2$attributes.font;\n\n  if (font) {\n    var _Object$assign;\n\n    var index = block.length - 1;\n    var codePoint = getEllipsisCodePoint(font);\n    var glyph = font.glyphForCodePoint(codePoint);\n    var lastBlock = append(glyph, trim(block[index]));\n    return Object.assign([], block, (_Object$assign = {}, _Object$assign[index] = lastBlock, _Object$assign));\n  }\n\n  return block;\n};\n/**\n * Omit attribute from run\n *\n * @param  {Object}  run\n * @return {Object} run without ommited attribute\n */\n\n\nvar omit = function omit(value, run) {\n  var attributes = Object.assign({}, run.attributes);\n  delete attributes[value];\n  return Object.assign({}, run, {\n    attributes: attributes\n  });\n};\n/**\n * Get run ascent\n *\n * @param  {Object}  run\n * @return {boolean} ascent\n */\n\n\nvar ascent$1 = function ascent(run) {\n  var _run$attributes, _run$attributes$attac, _run$attributes2, _run$attributes2$font;\n\n  var attachmentHeight = ((_run$attributes = run.attributes) === null || _run$attributes === void 0 ? void 0 : (_run$attributes$attac = _run$attributes.attachment) === null || _run$attributes$attac === void 0 ? void 0 : _run$attributes$attac.height) || 0;\n  var fontAscent = ((_run$attributes2 = run.attributes) === null || _run$attributes2 === void 0 ? void 0 : (_run$attributes2$font = _run$attributes2.font) === null || _run$attributes2$font === void 0 ? void 0 : _run$attributes2$font.ascent) || 0;\n  return Math.max(attachmentHeight, fontAscent * scale(run));\n};\n/**\n * Get run descent\n *\n * @param  {Object}  run\n * @return {number} descent\n */\n\n\nvar descent = function descent(run) {\n  var _run$attributes, _run$attributes$font;\n\n  var fontDescent = ((_run$attributes = run.attributes) === null || _run$attributes === void 0 ? void 0 : (_run$attributes$font = _run$attributes.font) === null || _run$attributes$font === void 0 ? void 0 : _run$attributes$font.descent) || 0;\n  return scale(run) * fontDescent;\n};\n/**\n * Get run lineGap\n *\n * @param  {Object}  run\n * @return {number} lineGap\n */\n\n\nvar lineGap = function lineGap(run) {\n  var _run$attributes, _run$attributes$font;\n\n  return (((_run$attributes = run.attributes) === null || _run$attributes === void 0 ? void 0 : (_run$attributes$font = _run$attributes.font) === null || _run$attributes$font === void 0 ? void 0 : _run$attributes$font.lineGap) || 0) * scale(run);\n};\n/**\n * Get run height\n *\n * @param  {Object}  run\n * @return {number} height\n */\n\n\nvar height$1 = function height(run) {\n  var _run$attributes;\n\n  var lineHeight = (_run$attributes = run.attributes) === null || _run$attributes === void 0 ? void 0 : _run$attributes.lineHeight;\n  return lineHeight || lineGap(run) + ascent$1(run) - descent(run);\n};\n/**\n * Returns attributed string height\n *\n * @param {Object} attributed string\n * @return {number} height\n */\n\n\nvar height = function height(attributeString) {\n  var reducer = function reducer(acc, run) {\n    return Math.max(acc, height$1(run));\n  };\n\n  return attributeString.runs.reduce(reducer, 0);\n};\n/**\n * Checks if two rects intersect each other\n *\n * @param {Rect} a\n * @param {Rect} b\n * @returns {Boolean} rects intersects\n */\n\n\nvar intersects = function intersects(a, b) {\n  var x = Math.max(a.x, b.x);\n  var num1 = Math.min(a.x + a.width, b.x + b.width);\n  var y = Math.max(a.y, b.y);\n  var num2 = Math.min(a.y + a.height, b.y + b.height);\n  return num1 >= x && num2 >= y;\n};\n\nvar _excluded = [\"excludeRects\"];\n\nvar getLineFragment = function getLineFragment(lineRect, excludeRect) {\n  if (!intersects(excludeRect, lineRect)) return [lineRect];\n  var eStart = excludeRect.x;\n  var eEnd = excludeRect.x + excludeRect.width;\n  var lStart = lineRect.x;\n  var lEnd = lineRect.x + lineRect.width;\n  var a = Object.assign({}, lineRect, {\n    width: eStart - lStart\n  });\n  var b = Object.assign({}, lineRect, {\n    x: eEnd,\n    width: lEnd - eEnd\n  });\n  return [a, b].filter(function (r) {\n    return r.width > 0;\n  });\n};\n\nvar getLineFragments = function getLineFragments(rect, excludeRects) {\n  var fragments = [rect];\n\n  var _loop = function _loop(i) {\n    var excludeRect = excludeRects[i];\n    fragments = fragments.reduce(function (acc, fragment) {\n      var pieces = getLineFragment(fragment, excludeRect);\n      return acc.concat(pieces);\n    }, []);\n  };\n\n  for (var i = 0; i < excludeRects.length; i += 1) {\n    _loop(i);\n  }\n\n  return fragments;\n};\n\nvar generateLineRects = function generateLineRects(container, height) {\n  var excludeRects = container.excludeRects,\n      rect = _objectWithoutPropertiesLoose(container, _excluded);\n\n  if (!excludeRects) return [rect];\n  var lineRects = [];\n  var maxY = Math.max.apply(Math, excludeRects.map(function (r) {\n    return r.y + r.height;\n  }));\n  var currentRect = rect;\n\n  while (currentRect.y < maxY) {\n    var _partition = partition(currentRect, height),\n        lineRect = _partition[0],\n        rest = _partition[1];\n\n    var lineRectFragments = getLineFragments(lineRect, excludeRects);\n    currentRect = rest;\n    lineRects.push.apply(lineRects, lineRectFragments);\n  }\n\n  return [].concat(lineRects, [currentRect]);\n};\n\nvar ATTACHMENT_CODE$1 = \"\\uFFFC\"; // 65532\n\n/**\n * Remove attachment attribute if no char present\n *\n * @param  {Object} attributed string\n * @return {Object} attributed string\n */\n\nvar purgeAttachments = function purgeAttachments(attributedString) {\n  var shouldPurge = !attributedString.string.includes(ATTACHMENT_CODE$1);\n  if (!shouldPurge) return attributedString;\n  var runs = attributedString.runs.map(function (run) {\n    return omit('attachment', run);\n  });\n  return Object.assign({}, attributedString, {\n    runs: runs\n  });\n};\n/**\n * Layout paragraphs inside rectangle\n *\n * @param  {Object} rect\n * @param  {Array} attributed strings\n * @return {Object} layout blocks\n */\n\n\nvar layoutLines = function layoutLines(rects, lines, indent) {\n  var rect = rects.shift();\n  var currentY = rect.y;\n  return lines.map(function (line, i) {\n    var _line$runs, _line$runs$;\n\n    var lineIndent = i === 0 ? indent : 0;\n    var style = ((_line$runs = line.runs) === null || _line$runs === void 0 ? void 0 : (_line$runs$ = _line$runs[0]) === null || _line$runs$ === void 0 ? void 0 : _line$runs$.attributes) || {};\n    var height$1 = Math.max(height(line), style.lineHeight);\n\n    if (currentY + height$1 > rect.y + rect.height && rects.length > 0) {\n      rect = rects.shift();\n      currentY = rect.y;\n    }\n\n    var newLine = Object.assign({}, line);\n    delete newLine.syllables;\n    newLine.box = {\n      x: rect.x + lineIndent,\n      y: currentY,\n      width: rect.width - lineIndent,\n      height: height$1\n    };\n    currentY += height$1;\n    return purgeAttachments(newLine);\n  });\n};\n/**\n * Performs line breaking and layout\n *\n * @param  {Object} engines\n * @param  {Object}  layout options\n * @param  {Object} rect\n * @param  {Object} attributed string\n * @return {Object} layout block\n */\n\n\nvar layoutParagraph = function layoutParagraph(engines, options) {\n  return function (container, paragraph) {\n    var _paragraph$runs, _paragraph$runs$, _paragraph$runs$$attr;\n\n    var height$1 = height(paragraph);\n    var indent = ((_paragraph$runs = paragraph.runs) === null || _paragraph$runs === void 0 ? void 0 : (_paragraph$runs$ = _paragraph$runs[0]) === null || _paragraph$runs$ === void 0 ? void 0 : (_paragraph$runs$$attr = _paragraph$runs$.attributes) === null || _paragraph$runs$$attr === void 0 ? void 0 : _paragraph$runs$$attr.indent) || 0;\n    var rects = generateLineRects(container, height$1);\n    var availableWidths = rects.map(function (r) {\n      return r.width;\n    });\n    availableWidths[0] -= indent;\n    var lines = engines.linebreaker(options)(paragraph, availableWidths);\n    return layoutLines(rects, lines, indent);\n  };\n};\n/**\n * Slice block at given height\n *\n * @param  {number}  height\n * @param  {Object}  paragraph block\n * @return {number} sliced paragraph block\n */\n\n\nvar sliceAtHeight = function sliceAtHeight(height, block) {\n  var newBlock = [];\n  var counter = 0;\n\n  for (var i = 0; i < block.length; i += 1) {\n    var line = block[i];\n    counter += line.box.height;\n\n    if (counter < height) {\n      newBlock.push(line);\n    } else {\n      break;\n    }\n  }\n\n  return newBlock;\n};\n/**\n * Layout paragraphs inside container until it does not\n * fit anymore, performing line wrapping in the process.\n *\n * @param  {Object}  engines\n * @param  {Object}  layout options\n * @param  {Object}  container rect\n * @param  {Object}  attributed strings (paragraphs)\n * @return {Array} paragraph blocks\n */\n\n\nvar typesetter = function typesetter(engines, options, container) {\n  return function (attributedStrings) {\n    var blocks = [];\n    var paragraphs = [].concat(attributedStrings);\n    var layoutBlock = layoutParagraph(engines, options);\n    var maxLines = isNil(container.maxLines) ? Infinity : container.maxLines;\n    var truncateEllipsis = container.truncateMode === 'ellipsis';\n    var linesCount = maxLines;\n    var paragraphRect = copy(container);\n    var nextParagraph = paragraphs.shift();\n\n    while (linesCount > 0 && nextParagraph) {\n      var block = layoutBlock(paragraphRect, nextParagraph);\n      var slicedBlock = block.slice(0, linesCount);\n      var linesHeight = height$2(slicedBlock);\n      var shouldTruncate = truncateEllipsis && block.length !== slicedBlock.length;\n      linesCount -= slicedBlock.length;\n\n      if (paragraphRect.height >= linesHeight) {\n        blocks.push(shouldTruncate ? truncate(slicedBlock) : slicedBlock);\n        paragraphRect = crop(linesHeight, paragraphRect);\n        nextParagraph = paragraphs.shift();\n      } else {\n        blocks.push(truncate(sliceAtHeight(paragraphRect.height, slicedBlock)));\n        break;\n      }\n    }\n\n    return blocks;\n  };\n};\n\nvar DUMMY_CODEPOINT = 123;\n/**\n * Resolve string indices based on glyphs code points\n *\n * @param  {Array}  glyphs\n * @return {Array} glyph indices\n */\n\nvar resolve = function resolve(glyphs) {\n  if (glyphs === void 0) {\n    glyphs = [];\n  }\n\n  return glyphs.reduce(function (acc, glyph) {\n    var codePoints = (glyph === null || glyph === void 0 ? void 0 : glyph.codePoints) || [DUMMY_CODEPOINT];\n    if (acc.length === 0) return codePoints.map(function () {\n      return 0;\n    });\n    var last = acc[acc.length - 1];\n    var next = codePoints.map(function () {\n      return last + 1;\n    });\n    return [].concat(acc, next);\n  }, []);\n};\n\nvar getCharacterSpacing = function getCharacterSpacing(run) {\n  var _run$attributes;\n\n  return ((_run$attributes = run.attributes) === null || _run$attributes === void 0 ? void 0 : _run$attributes.characterSpacing) || 0;\n};\n/**\n * Scale run positions\n *\n * @param  {Object}  run\n * @param  {Array}  positions\n * @return {Array} scaled positions\n */\n\n\nvar scalePositions = function scalePositions(run, positions) {\n  var runScale = scale(run);\n  var characterSpacing = getCharacterSpacing(run);\n  return positions.map(function (position, i) {\n    var isLast = i === positions.length;\n    var xSpacing = isLast ? 0 : characterSpacing;\n    return Object.assign({}, position, {\n      xAdvance: position.xAdvance * runScale + xSpacing,\n      yAdvance: position.yAdvance * runScale,\n      xOffset: position.xOffset * runScale,\n      yOffset: position.yOffset * runScale\n    });\n  });\n};\n/**\n * Create glyph run\n *\n * @param  {String}  string\n * @param  {Object}  run\n * @return {Object}  glyph run\n */\n\n\nvar layoutRun = function layoutRun(string) {\n  return function (run) {\n    var start = run.start,\n        end = run.end,\n        _run$attributes2 = run.attributes,\n        attributes = _run$attributes2 === void 0 ? {} : _run$attributes2;\n    var font = attributes.font;\n    if (!font) return _extends({}, run, {\n      glyphs: [],\n      glyphIndices: [],\n      positions: []\n    });\n    var runString = string.slice(start, end);\n    var glyphRun = font.layout(runString);\n    var positions = scalePositions(run, glyphRun.positions);\n    var glyphIndices = resolve(glyphRun.glyphs);\n    return _extends({}, run, {\n      positions: positions,\n      glyphIndices: glyphIndices,\n      glyphs: glyphRun.glyphs\n    });\n  };\n};\n/**\n * Generate glyphs for single attributed string\n *\n * @param  {Object}  layout engines\n * @param  {Object}  layout options\n * @param  {Array}  attributed strings\n * @return {Array} attributed string with glyphs\n */\n\n\nvar generateGlyphs = function generateGlyphs() {\n  return function (attributedString) {\n    var runs = attributedString.runs.map(layoutRun(attributedString.string));\n    return Object.assign({}, attributedString, {\n      runs: runs\n    });\n  };\n};\n/**\n * Resolves yOffset for run\n *\n * @param  {Object}  run\n * @return {Object} run\n */\n\n\nvar resolveRunYOffset = function resolveRunYOffset(run) {\n  var _run$attributes, _run$attributes$font, _run$attributes2;\n\n  if (!run.positions) return run;\n  var unitsPerEm = ((_run$attributes = run.attributes) === null || _run$attributes === void 0 ? void 0 : (_run$attributes$font = _run$attributes.font) === null || _run$attributes$font === void 0 ? void 0 : _run$attributes$font.unitsPerEm) || 0;\n  var yOffset = (((_run$attributes2 = run.attributes) === null || _run$attributes2 === void 0 ? void 0 : _run$attributes2.yOffset) || 0) * unitsPerEm;\n  var positions = run.positions.map(function (p) {\n    return Object.assign({}, p, {\n      yOffset: yOffset\n    });\n  });\n  return Object.assign({}, run, {\n    positions: positions\n  });\n};\n/**\n * Resolves yOffset for multiple paragraphs\n *\n * @param  {Object} layout engines\n * @param  {Object}  layout options\n * @param  {Array}  attributed strings (paragraphs)\n * @return {Array} attributed strings (paragraphs)\n */\n\n\nvar resolveYOffset = function resolveYOffset() {\n  return function (attributedString) {\n    var runs = attributedString.runs.map(resolveRunYOffset);\n    return Object.assign({}, attributedString, {\n      runs: runs\n    });\n  };\n};\n/**\n * Sort runs in ascending order\n *\n * @param  {Array}  runs\n * @return {Array} sorted runs\n */\n\n\nvar sort = function sort(runs) {\n  return runs.sort(function (a, b) {\n    return a.start - b.start || a.end - b.end;\n  });\n};\n/**\n * Is run empty (start === end)\n *\n * @param  {Object}  run\n * @return {Object} is run empty\n */\n\n\nvar isEmpty = function isEmpty(run) {\n  return run.start === run.end;\n};\n\nvar sortPoints = function sortPoints(a, b) {\n  return a[1] - b[1] || a[3] - b[3];\n};\n\nvar generatePoints = function generatePoints(runs) {\n  var result = runs.reduce(function (acc, run, i) {\n    return acc.concat([['start', run.start, run.attributes, i], ['end', run.end, run.attributes, i]]);\n  }, []);\n  return result.sort(sortPoints);\n};\n\nvar mergeRuns = function mergeRuns(runs) {\n  return runs.reduce(function (acc, run) {\n    var attributes = Object.assign({}, acc.attributes, run.attributes);\n    return Object.assign({}, run, {\n      attributes: attributes\n    });\n  }, {});\n};\n\nvar groupEmptyRuns = function groupEmptyRuns(runs) {\n  var groups = runs.reduce(function (acc, run) {\n    if (!acc[run.start]) acc[run.start] = [];\n    acc[run.start].push(run);\n    return acc;\n  }, {});\n  return Object.values(groups);\n};\n\nvar flattenEmptyRuns = function flattenEmptyRuns(runs) {\n  return groupEmptyRuns(runs).map(mergeRuns);\n};\n\nvar flattenRegularRuns = function flattenRegularRuns(runs) {\n  var res = [];\n  var points = generatePoints(runs);\n  var start = -1;\n  var attrs = {};\n  var stack = [];\n\n  for (var i = 0; i < points.length; i += 1) {\n    var _points$i = points[i],\n        type = _points$i[0],\n        offset = _points$i[1],\n        attributes = _points$i[2];\n\n    if (start !== -1 && start < offset) {\n      res.push({\n        start: start,\n        end: offset,\n        attributes: attrs\n      });\n    }\n\n    if (type === 'start') {\n      stack.push(attributes);\n      attrs = Object.assign({}, attrs, attributes);\n    } else {\n      attrs = {};\n\n      for (var j = 0; j < stack.length; j += 1) {\n        if (stack[j] === attributes) {\n          // eslint-disable-next-line no-plusplus\n          stack.splice(j--, 1);\n        } else {\n          attrs = Object.assign({}, attrs, stack[j]);\n        }\n      }\n    }\n\n    start = offset;\n  }\n\n  return res;\n};\n/**\n * Flatten many runs\n *\n * @param  {Array}  runs\n * @return {Array} flatten runs\n */\n\n\nvar flatten = function flatten(runs) {\n  if (runs === void 0) {\n    runs = [];\n  }\n\n  var emptyRuns = flattenEmptyRuns(runs.filter(function (run) {\n    return isEmpty(run);\n  }));\n  var regularRuns = flattenRegularRuns(runs.filter(function (run) {\n    return !isEmpty(run);\n  }));\n  return sort(emptyRuns.concat(regularRuns));\n};\n/**\n * Returns empty attributed string\n *\n * @return {Object} empty attributed string\n */\n\n\nvar empty = function empty() {\n  return {\n    string: '',\n    runs: []\n  };\n};\n\nvar omitFont = function omitFont(attributedString) {\n  var runs = attributedString.runs.map(function (run) {\n    return omit('font', run);\n  });\n  return Object.assign({}, attributedString, {\n    runs: runs\n  });\n};\n/**\n * Performs font substitution and script itemization on attributed string\n *\n * @param  {Object}  engines\n * @param  {Object}  layout options\n * @param  {Object}  attributed string\n * @return {Object} processed attributed string\n */\n\n\nvar preprocessRuns = function preprocessRuns(engines, options) {\n  return function (attributedString) {\n    if (isNil(attributedString)) return empty();\n    var string = attributedString.string;\n    var fontSubstitution = engines.fontSubstitution,\n        scriptItemizer = engines.scriptItemizer;\n\n    var _omitFont = omitFont(attributedString),\n        omittedFontRuns = _omitFont.runs;\n\n    var _fontSubstitution = fontSubstitution(options)(attributedString),\n        substitutedRuns = _fontSubstitution.runs;\n\n    var _scriptItemizer = scriptItemizer(options)(attributedString),\n        itemizationRuns = _scriptItemizer.runs;\n\n    var runs = substitutedRuns.concat(itemizationRuns).concat(omittedFontRuns);\n    return {\n      string: string,\n      runs: flatten(runs)\n    };\n  };\n};\n/**\n * Get attributed string start value\n *\n * @param  {Object}  attributed string\n * @return {number} start\n */\n\n\nvar start = function start(attributedString) {\n  var runs = attributedString.runs;\n  return runs.length === 0 ? 0 : runs[0].start;\n};\n/**\n * Get attributed string end value\n *\n * @param  {Object}  attributed string\n * @return {number} end\n */\n\n\nvar end = function end(attributedString) {\n  var runs = attributedString.runs;\n  return runs.length === 0 ? 0 : last(runs).end;\n};\n/**\n * Get attributed string length\n *\n * @param  {Object}  glyph string\n * @return {number} end\n */\n\n\nvar length$1 = function length(attributedString) {\n  return end(attributedString) - start(attributedString);\n};\n/**\n * Breaks attributed string into paragraphs\n *\n * @param  {Object}  engines\n * @param  {Object}  layout options\n * @param  {Object}  attributed string\n * @return {Array} attributed string array\n */\n\n\nvar splitParagraphs = function splitParagraphs() {\n  return function (attributedString) {\n    var res = [];\n    var start = 0;\n    var breakPoint = attributedString.string.indexOf('\\n') + 1;\n\n    while (breakPoint > 0) {\n      res.push(slice(start, breakPoint, attributedString));\n      start = breakPoint;\n      breakPoint = attributedString.string.indexOf('\\n', breakPoint) + 1;\n    }\n\n    if (start === 0) {\n      res.push(attributedString);\n    } else if (start < attributedString.string.length) {\n      res.push(slice(start, length$1(attributedString), attributedString));\n    }\n\n    return res;\n  };\n};\n/**\n * Return positions advance width\n *\n * @param  {Object}  positions\n * @return {number} advance width\n */\n\n\nvar advanceWidth$2 = function advanceWidth(positions) {\n  return positions.reduce(function (acc, pos) {\n    return acc + (pos.xAdvance || 0);\n  }, 0);\n};\n/**\n * Return run advance width\n *\n * @param  {Object}  run\n * @return {number} advance width\n */\n\n\nvar advanceWidth$1 = function advanceWidth(run) {\n  return advanceWidth$2(run.positions || []);\n};\n/**\n * Returns attributed string advancewidth\n *\n * @param {Object} attributed string\n * @return {number} advance width\n */\n\n\nvar advanceWidth = function advanceWidth(attributeString) {\n  var reducer = function reducer(acc, run) {\n    return acc + advanceWidth$1(run);\n  };\n\n  return attributeString.runs.reduce(reducer, 0);\n};\n\nvar WHITE_SPACES_CODE = 32;\n/**\n * Check if glyph is white space\n *\n * @param  {Object}  glyph\n * @return {Boolean}  is white space\n * */\n\nvar isWhiteSpace = function isWhiteSpace(glyph) {\n  var codePoints = (glyph === null || glyph === void 0 ? void 0 : glyph.codePoints) || [];\n  return codePoints.includes(WHITE_SPACES_CODE);\n};\n/**\n * Get white space leading positions\n *\n * @param  {Object}  run\n * @return {Array} white space leading positions\n */\n\n\nvar leadingPositions = function leadingPositions(run) {\n  var glyphs = run.glyphs || [];\n  var positions = run.positions || [];\n  var leadingWhitespaces = glyphs.findIndex(function (g) {\n    return !isWhiteSpace(g);\n  });\n  return positions.slice(0, leadingWhitespaces);\n};\n/**\n * Get run leading white space offset\n *\n * @param  {Object}  run\n * @return {number} leading white space offset\n */\n\n\nvar leadingOffset$1 = function leadingOffset(run) {\n  var positions = leadingPositions(run);\n  return positions.reduce(function (acc, pos) {\n    return acc + (pos.xAdvance || 0);\n  }, 0);\n};\n/**\n * Get attributed string leading white space offset\n *\n * @param  {Object}  attributed string\n * @return {number} leading white space offset\n */\n\n\nvar leadingOffset = function leadingOffset(attributedString) {\n  var runs = attributedString.runs || [];\n  return leadingOffset$1(runs[0]);\n};\n\nvar reverse = function reverse(array) {\n  return [].concat(array).reverse();\n};\n/**\n * Get white space trailing positions\n *\n * @param  {Object}  run\n * @return {Array} white space trailing positions\n */\n\n\nvar trailingPositions = function trailingPositions(run) {\n  var glyphs = reverse(run.glyphs || []);\n  var positions = reverse(run.positions || []);\n  var leadingWhitespaces = glyphs.findIndex(function (g) {\n    return !isWhiteSpace(g);\n  });\n  return positions.slice(0, leadingWhitespaces);\n};\n/**\n * Get run trailing white space offset\n *\n * @param  {Object}  run\n * @return {number} trailing white space offset\n */\n\n\nvar trailingOffset$1 = function trailingOffset(run) {\n  var positions = trailingPositions(run);\n  return positions.reduce(function (acc, pos) {\n    return acc + (pos.xAdvance || 0);\n  }, 0);\n};\n/**\n * Get attributed string trailing white space offset\n *\n * @param  {Object}  attributed string\n * @return {number} trailing white space offset\n */\n\n\nvar trailingOffset = function trailingOffset(attributedString) {\n  var runs = attributedString.runs || [];\n  return trailingOffset$1(last(runs));\n};\n/**\n * Drop last char of run\n *\n * @param  {Object}  run\n * @return {boolean} run without last char\n */\n\n\nvar dropLast$1 = function dropLast(run) {\n  return slice$1(0, run.end - run.start - 1, run);\n};\n/**\n * Drop last glyph\n *\n * @param {Object} attributed string\n * @return {Object} attributed string with new glyph\n */\n\n\nvar dropLast = function dropLast(attributeString) {\n  var string = dropLast$2(attributeString.string);\n  var runs = adjust(-1, dropLast$1, attributeString.runs);\n  return Object.assign({}, attributeString, {\n    string: string,\n    runs: runs\n  });\n};\n\nvar ALIGNMENT_FACTORS = {\n  center: 0.5,\n  right: 1\n};\n/**\n * Remove new line char at the end of line if present\n *\n * @param  {Object}  line\n * @return {Object} line\n */\n\nvar removeNewLine = function removeNewLine(line) {\n  return last(line.string) === '\\n' ? dropLast(line) : line;\n};\n\nvar getOverflowLeft = function getOverflowLeft(line) {\n  return leadingOffset(line) + (line.overflowLeft || 0);\n};\n\nvar getOverflowRight = function getOverflowRight(line) {\n  return trailingOffset(line) + (line.overflowRight || 0);\n};\n/**\n * Ignore whitespace at the start and end of a line for alignment\n *\n * @param  {Object}  line\n * @return {Object} line\n */\n\n\nvar adjustOverflow = function adjustOverflow(line) {\n  var overflowLeft = getOverflowLeft(line);\n  var overflowRight = getOverflowRight(line);\n  var x = line.box.x - overflowLeft;\n  var width = line.box.width + overflowLeft + overflowRight;\n  var box = Object.assign({}, line.box, {\n    x: x,\n    width: width\n  });\n  return Object.assign({}, line, {\n    box: box,\n    overflowLeft: overflowLeft,\n    overflowRight: overflowRight\n  });\n};\n/**\n * Performs line justification by calling appropiate engine\n *\n * @param  {Object}  engines\n * @param  {Object}  layout options\n * @param  {string}  text align\n * @param  {Object}  line\n * @return {Object} line\n */\n\n\nvar justifyLine$1 = function justifyLine(engines, options, align) {\n  return function (line) {\n    var lineWidth = advanceWidth(line);\n    var alignFactor = ALIGNMENT_FACTORS[align] || 0;\n    var remainingWidth = Math.max(0, line.box.width - lineWidth);\n    var shouldJustify = align === 'justify' || lineWidth > line.box.width;\n    var x = line.box.x + remainingWidth * alignFactor;\n    var box = Object.assign({}, line.box, {\n      x: x\n    });\n    var newLine = Object.assign({}, line, {\n      box: box\n    });\n    return shouldJustify ? engines.justification(options)(newLine) : newLine;\n  };\n};\n\nvar finalizeLine = function finalizeLine(line) {\n  var lineAscent = 0;\n  var lineDescent = 0;\n  var lineHeight = 0;\n  var lineXAdvance = 0;\n  var runs = line.runs.map(function (run) {\n    var height = height$1(run);\n    var ascent = ascent$1(run);\n    var descent$1 = descent(run);\n    var xAdvance = advanceWidth$1(run);\n    lineHeight = Math.max(lineHeight, height);\n    lineAscent = Math.max(lineAscent, ascent);\n    lineDescent = Math.max(lineDescent, descent$1);\n    lineXAdvance += xAdvance;\n    return Object.assign({}, run, {\n      height: height,\n      ascent: ascent,\n      descent: descent$1,\n      xAdvance: xAdvance\n    });\n  });\n  return Object.assign({}, line, {\n    runs: runs,\n    height: lineHeight,\n    ascent: lineAscent,\n    descent: lineDescent,\n    xAdvance: lineXAdvance\n  });\n};\n/**\n * Finalize line by performing line justification\n * and text decoration (using appropiate engines)\n *\n * @param  {Object}  engines\n * @param  {Object}  layout options\n * @param  {Object}  line\n * @param  {number}  line index\n * @param  {Array}  total lines\n * @return {Object} line\n */\n\n\nvar finalizeBlock = function finalizeBlock(engines, options) {\n  if (engines === void 0) {\n    engines = {};\n  }\n\n  return function (line, i, lines) {\n    var _line$runs, _line$runs$;\n\n    var isLastFragment = i === lines.length - 1;\n    var style = ((_line$runs = line.runs) === null || _line$runs === void 0 ? void 0 : (_line$runs$ = _line$runs[0]) === null || _line$runs$ === void 0 ? void 0 : _line$runs$.attributes) || {};\n    var align = isLastFragment ? style.alignLastLine : style.align;\n    return compose(finalizeLine, engines.textDecoration(options), justifyLine$1(engines, options, align), adjustOverflow, removeNewLine)(line);\n  };\n};\n/**\n * Finalize line block by performing line justification\n * and text decoration (using appropiate engines)\n *\n * @param  {Object}  engines\n * @param  {Object}  layout options\n * @param  {Array}  line blocks\n * @return {Array} line blocks\n */\n\n\nvar finalizeFragments = function finalizeFragments(engines, options) {\n  return function (blocks) {\n    var blockFinalizer = finalizeBlock(engines, options);\n    return blocks.map(function (block) {\n      return block.map(blockFinalizer);\n    });\n  };\n};\n\nvar ATTACHMENT_CODE = 0xfffc; // 65532\n\nvar isReplaceGlyph = function isReplaceGlyph(glyph) {\n  return glyph.codePoints.includes(ATTACHMENT_CODE);\n};\n/**\n * Resolve attachments of run\n *\n * @param  {Object}  run\n * @return {Object} run\n */\n\n\nvar resolveRunAttachments = function resolveRunAttachments(run) {\n  var _run$attributes;\n\n  if (!run.positions) return run;\n  var glyphs = run.glyphs || [];\n  var attachment = ((_run$attributes = run.attributes) === null || _run$attributes === void 0 ? void 0 : _run$attributes.attachment) || {};\n  var positions = run.positions.map(function (position, i) {\n    var glyph = glyphs[i];\n\n    if (attachment && attachment.width && isReplaceGlyph(glyph)) {\n      return Object.assign({}, position, {\n        xAdvance: attachment.width\n      });\n    }\n\n    return Object.assign({}, position);\n  });\n  return Object.assign({}, run, {\n    positions: positions\n  });\n};\n/**\n * Resolve attachments for multiple paragraphs\n *\n * @param  {Object} layout engines\n * @param  {Object}  layout options\n * @param  {Array}  attributed strings (paragraphs)\n * @return {Array} attributed strings (paragraphs)\n */\n\n\nvar resolveAttachments = function resolveAttachments() {\n  return function (attributedString) {\n    var runs = attributedString.runs.map(resolveRunAttachments);\n    return Object.assign({}, attributedString, {\n      runs: runs\n    });\n  };\n};\n\nvar applyAttributes = function applyAttributes(a) {\n  return {\n    align: a.align || 'left',\n    alignLastLine: a.alignLastLine || (a.align === 'justify' ? 'left' : a.align || 'left'),\n    attachment: a.attachment || null,\n    backgroundColor: a.backgroundColor || null,\n    bidiLevel: a.bidiLevel || null,\n    bullet: a.bullet || null,\n    characterSpacing: a.characterSpacing || 0,\n    color: a.color || 'black',\n    features: a.features || [],\n    fill: a.fill !== false,\n    font: a.font || null,\n    fontSize: a.fontSize || 12,\n    hangingPunctuation: a.hangingPunctuation || false,\n    hyphenationFactor: a.hyphenationFactor || 0,\n    indent: a.indent || 0,\n    justificationFactor: a.justificationFactor || 1,\n    lineHeight: a.lineHeight || null,\n    lineSpacing: a.lineSpacing || 0,\n    link: a.link || null,\n    marginLeft: a.marginLeft || a.margin || 0,\n    marginRight: a.marginRight || a.margin || 0,\n    opacity: a.opacity,\n    paddingTop: a.paddingTop || a.padding || 0,\n    paragraphSpacing: a.paragraphSpacing || 0,\n    underline: a.underline || false,\n    underlineColor: a.underlineColor || a.color || 'black',\n    underlineStyle: a.underlineStyle || 'solid',\n    script: a.script || null,\n    shrinkFactor: a.shrinkFactor || 0,\n    strike: a.strike || false,\n    strikeColor: a.strikeColor || a.color || 'black',\n    strikeStyle: a.strikeStyle || 'solid',\n    stroke: a.stroke || false,\n    wordSpacing: a.wordSpacing || 0,\n    yOffset: a.yOffset || 0\n  };\n};\n/**\n * Apply default style to run\n *\n * @param  {Object}  run\n * @return {Object} run with styles\n */\n\n\nvar applyRunStyles = function applyRunStyles(run) {\n  var attributes = applyAttributes(run.attributes);\n  return Object.assign({}, run, {\n    attributes: attributes\n  });\n};\n/**\n * Apply default attributes for an attributed string\n *\n * @param  {Object}  engines\n * @param  {Object}  layout options\n * @param  {Object}  attributed string\n * @return {Object} attributed string\n */\n\n\nvar applyDefaultStyles = function applyDefaultStyles() {\n  return function (attributedString) {\n    var string = attributedString.string || '';\n    var runs = (attributedString.runs || []).map(applyRunStyles);\n    return {\n      string: string,\n      runs: runs\n    };\n  };\n};\n/**\n * A LayoutEngine is the main object that performs text layout.\n * It accepts an AttributedString and a Container object\n * to layout text into, and uses several helper objects to perform\n * various layout tasks. These objects can be overridden to customize\n * layout behavior.\n *\n * @param  {Object}  engines\n * @param  {Object}  attributed string\n * @param  {Object}  container rect\n * @param  {Object}  layout options\n * @return {Array} paragraph blocks\n */\n\n\nvar layoutEngine = function layoutEngine(engines) {\n  return function (attributedString, container, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    var processParagraph = compose(resolveYOffset(), resolveAttachments(), generateGlyphs(), wrapWords(engines, options));\n\n    var processParagraphs = function processParagraphs(paragraphs) {\n      return paragraphs.map(processParagraph);\n    };\n\n    return compose(finalizeFragments(engines, options), typesetter(engines, options, container), processParagraphs, splitParagraphs(), preprocessRuns(engines, options), applyDefaultStyles())(attributedString);\n  };\n};\n/* eslint-disable no-plusplus */\n\n\nvar INFINITY = 10000;\n\nvar getNextBreakpoint = function getNextBreakpoint(subnodes, widths, lineNumber) {\n  var position = null;\n  var minimumBadness = Infinity;\n  var sum = {\n    width: 0,\n    stretch: 0,\n    shrink: 0\n  };\n  var lineLength = widths[Math.min(lineNumber, widths.length - 1)];\n\n  var calculateRatio = function calculateRatio(node) {\n    if (sum.width < lineLength) {\n      return sum.stretch - node.stretch > 0 ? (lineLength - sum.width) / sum.stretch : INFINITY;\n    }\n\n    if (sum.width > lineLength) {\n      return sum.shrink - node.shrink > 0 ? (lineLength - sum.width) / sum.shrink : INFINITY;\n    }\n\n    return 0;\n  };\n\n  for (var i = 0; i < subnodes.length; i += 1) {\n    var node = subnodes[i];\n\n    if (node.type === 'box') {\n      sum.width += node.width;\n    } else if (node.type === 'glue') {\n      sum.width += node.width;\n      sum.stretch += node.stretch;\n      sum.shrink += node.shrink;\n    }\n\n    if (sum.width - sum.shrink > lineLength) {\n      if (position === null) {\n        var j = i === 0 ? i + 1 : i;\n\n        while (j < subnodes.length && (subnodes[j].type === 'glue' || subnodes[j].type === 'penalty')) {\n          j++;\n        }\n\n        position = j - 1;\n      }\n\n      break;\n    }\n\n    if (node.type === 'penalty' || node.type === 'glue') {\n      var ratio = calculateRatio(node);\n      var penalty = node.type === 'penalty' ? node.penalty : 0;\n      var badness = 100 * Math.pow(Math.abs(ratio), 3) + penalty;\n\n      if (minimumBadness >= badness) {\n        position = i;\n        minimumBadness = badness;\n      }\n    }\n  }\n\n  return sum.width - sum.shrink > lineLength ? position : null;\n};\n\nvar applyBestFit = function applyBestFit(nodes, widths) {\n  var count = 0;\n  var lineNumber = 0;\n  var subnodes = nodes;\n  var breakpoints = [{\n    position: 0\n  }];\n\n  while (subnodes.length > 0) {\n    var breakpoint = getNextBreakpoint(subnodes, widths, lineNumber);\n\n    if (breakpoint !== null) {\n      count += breakpoint;\n      breakpoints.push({\n        position: count\n      });\n      subnodes = subnodes.slice(breakpoint + 1, subnodes.length);\n      count++;\n      lineNumber++;\n    } else {\n      subnodes = [];\n    }\n  }\n\n  return breakpoints;\n};\n/* eslint-disable no-param-reassign */\n\n/* eslint-disable max-classes-per-file */\n\n\nvar Node = /*#__PURE__*/function () {\n  function Node(data) {\n    this.prev = null;\n    this.next = null;\n    this.data = data;\n  }\n\n  var _proto = Node.prototype;\n\n  _proto.toString = function toString() {\n    return this.data.toString();\n  };\n\n  return Node;\n}();\n\nvar LinkedList = /*#__PURE__*/function () {\n  function LinkedList() {\n    this.head = null;\n    this.tail = null;\n    this.listSize = 0;\n  }\n\n  var _proto2 = LinkedList.prototype;\n\n  _proto2.isLinked = function isLinked(node) {\n    return !(node && node.prev === null && node.next === null && this.tail !== node && this.head !== node || this.isEmpty());\n  };\n\n  _proto2.size = function size() {\n    return this.listSize;\n  };\n\n  _proto2.isEmpty = function isEmpty() {\n    return this.listSize === 0;\n  };\n\n  _proto2.first = function first() {\n    return this.head;\n  };\n\n  _proto2.last = function last() {\n    return this.last;\n  };\n\n  _proto2.toString = function toString() {\n    return this.toArray().toString();\n  };\n\n  _proto2.toArray = function toArray() {\n    var node = this.head;\n    var result = [];\n\n    while (node !== null) {\n      result.push(node);\n      node = node.next;\n    }\n\n    return result;\n  };\n\n  _proto2.forEach = function forEach(fun) {\n    var node = this.head;\n\n    while (node !== null) {\n      fun(node);\n      node = node.next;\n    }\n  };\n\n  _proto2.contains = function contains(n) {\n    var node = this.head;\n\n    if (!this.isLinked(n)) {\n      return false;\n    }\n\n    while (node !== null) {\n      if (node === n) {\n        return true;\n      }\n\n      node = node.next;\n    }\n\n    return false;\n  };\n\n  _proto2.at = function at(i) {\n    var node = this.head;\n    var index = 0;\n\n    if (i >= this.listLength || i < 0) {\n      return null;\n    }\n\n    while (node !== null) {\n      if (i === index) {\n        return node;\n      }\n\n      node = node.next;\n      index += 1;\n    }\n\n    return null;\n  };\n\n  _proto2.insertAfter = function insertAfter(node, newNode) {\n    if (!this.isLinked(node)) {\n      return this;\n    }\n\n    newNode.prev = node;\n    newNode.next = node.next;\n\n    if (node.next === null) {\n      this.tail = newNode;\n    } else {\n      node.next.prev = newNode;\n    }\n\n    node.next = newNode;\n    this.listSize += 1;\n    return this;\n  };\n\n  _proto2.insertBefore = function insertBefore(node, newNode) {\n    if (!this.isLinked(node)) {\n      return this;\n    }\n\n    newNode.prev = node.prev;\n    newNode.next = node;\n\n    if (node.prev === null) {\n      this.head = newNode;\n    } else {\n      node.prev.next = newNode;\n    }\n\n    node.prev = newNode;\n    this.listSize += 1;\n    return this;\n  };\n\n  _proto2.push = function push(node) {\n    if (this.head === null) {\n      this.unshift(node);\n    } else {\n      this.insertAfter(this.tail, node);\n    }\n\n    return this;\n  };\n\n  _proto2.unshift = function unshift(node) {\n    if (this.head === null) {\n      this.head = node;\n      this.tail = node;\n      node.prev = null;\n      node.next = null;\n      this.listSize += 1;\n    } else {\n      this.insertBefore(this.head, node);\n    }\n\n    return this;\n  };\n\n  _proto2.remove = function remove(node) {\n    if (!this.isLinked(node)) {\n      return this;\n    }\n\n    if (node.prev === null) {\n      this.head = node.next;\n    } else {\n      node.prev.next = node.next;\n    }\n\n    if (node.next === null) {\n      this.tail = node.prev;\n    } else {\n      node.next.prev = node.prev;\n    }\n\n    this.listSize -= 1;\n    return this;\n  };\n\n  _proto2.pop = function pop() {\n    var node = this.tail;\n    this.tail.prev.next = null;\n    this.tail = this.tail.prev;\n    this.listSize -= 1;\n    node.prev = null;\n    node.next = null;\n    return node;\n  };\n\n  _proto2.shift = function shift() {\n    var node = this.head;\n    this.head.next.prev = null;\n    this.head = this.head.next;\n    this.listSize -= 1;\n    node.prev = null;\n    node.next = null;\n    return node;\n  };\n\n  return LinkedList;\n}();\n\nLinkedList.Node = Node;\n/* eslint-disable no-restricted-properties */\n\n/**\n * @preserve Knuth and Plass line breaking algorithm in JavaScript\n *\n * Licensed under the new BSD License.\n * Copyright 2009-2010, Bram Stein\n * All rights reserved.\n */\n\nvar linebreak = function linebreak(nodes, lines, settings) {\n  var options = {\n    demerits: {\n      line: settings && settings.demerits && settings.demerits.line || 10,\n      flagged: settings && settings.demerits && settings.demerits.flagged || 100,\n      fitness: settings && settings.demerits && settings.demerits.fitness || 3000\n    },\n    tolerance: settings && settings.tolerance || 3\n  };\n  var activeNodes = new LinkedList();\n  var sum = {\n    width: 0,\n    stretch: 0,\n    shrink: 0\n  };\n  var lineLengths = lines;\n  var breaks = [];\n  var tmp = {\n    data: {\n      demerits: Infinity\n    }\n  };\n\n  function breakpoint(position, demerits, ratio, line, fitnessClass, totals, previous) {\n    return {\n      position: position,\n      demerits: demerits,\n      ratio: ratio,\n      line: line,\n      fitnessClass: fitnessClass,\n      totals: totals || {\n        width: 0,\n        stretch: 0,\n        shrink: 0\n      },\n      previous: previous\n    };\n  }\n\n  function computeCost(start, end, active, currentLine) {\n    var width = sum.width - active.totals.width;\n    var stretch = 0;\n    var shrink = 0; // If the current line index is within the list of linelengths, use it, otherwise use\n    // the last line length of the list.\n\n    var lineLength = currentLine < lineLengths.length ? lineLengths[currentLine - 1] : lineLengths[lineLengths.length - 1];\n\n    if (nodes[end].type === 'penalty') {\n      width += nodes[end].width;\n    }\n\n    if (width < lineLength) {\n      // Calculate the stretch ratio\n      stretch = sum.stretch - active.totals.stretch;\n\n      if (stretch > 0) {\n        return (lineLength - width) / stretch;\n      }\n\n      return linebreak.infinity;\n    }\n\n    if (width > lineLength) {\n      // Calculate the shrink ratio\n      shrink = sum.shrink - active.totals.shrink;\n\n      if (shrink > 0) {\n        return (lineLength - width) / shrink;\n      }\n\n      return linebreak.infinity;\n    } // perfect match\n\n\n    return 0;\n  } // Add width, stretch and shrink values from the current\n  // break point up to the next box or forced penalty.\n\n\n  function computeSum(breakPointIndex) {\n    var result = {\n      width: sum.width,\n      stretch: sum.stretch,\n      shrink: sum.shrink\n    };\n\n    for (var i = breakPointIndex; i < nodes.length; i += 1) {\n      if (nodes[i].type === 'glue') {\n        result.width += nodes[i].width;\n        result.stretch += nodes[i].stretch;\n        result.shrink += nodes[i].shrink;\n      } else if (nodes[i].type === 'box' || nodes[i].type === 'penalty' && nodes[i].penalty === -linebreak.infinity && i > breakPointIndex) {\n        break;\n      }\n    }\n\n    return result;\n  } // The main loop of the algorithm\n  // eslint-disable-next-line no-shadow\n\n\n  function mainLoop(node, index, nodes) {\n    var active = activeNodes.first();\n    var next = null;\n    var ratio = 0;\n    var demerits = 0;\n    var candidates = [];\n    var badness;\n    var currentLine = 0;\n    var tmpSum;\n    var currentClass = 0;\n    var fitnessClass;\n    var candidate;\n    var newNode; // The inner loop iterates through all the active nodes with line < currentLine and then\n    // breaks out to insert the new active node candidates before looking at the next active\n    // nodes for the next lines. The result of this is that the active node list is always\n    // sorted by line number.\n\n    while (active !== null) {\n      candidates = [{\n        demerits: Infinity\n      }, {\n        demerits: Infinity\n      }, {\n        demerits: Infinity\n      }, {\n        demerits: Infinity\n      }]; // Iterate through the linked list of active nodes to find new potential active nodes\n      // and deactivate current active nodes.\n\n      while (active !== null) {\n        next = active.next;\n        currentLine = active.data.line + 1;\n        ratio = computeCost(active.data.position, index, active.data, currentLine); // Deactive nodes when the distance between the current active node and the\n        // current node becomes too large (i.e. it exceeds the stretch limit and the stretch\n        // ratio becomes negative) or when the current node is a forced break (i.e. the end\n        // of the paragraph when we want to remove all active nodes, but possibly have a final\n        // candidate active node---if the paragraph can be set using the given tolerance value.)\n\n        if (ratio < -1 || node.type === 'penalty' && node.penalty === -linebreak.infinity) {\n          activeNodes.remove(active);\n        } // If the ratio is within the valid range of -1 <= ratio <= tolerance calculate the\n        // total demerits and record a candidate active node.\n\n\n        if (ratio >= -1 && ratio <= options.tolerance) {\n          badness = 100 * Math.pow(Math.abs(ratio), 3); // Positive penalty\n\n          if (node.type === 'penalty' && node.penalty >= 0) {\n            demerits = Math.pow(options.demerits.line + badness, 2) + Math.pow(node.penalty, 2); // Negative penalty but not a forced break\n          } else if (node.type === 'penalty' && node.penalty !== -linebreak.infinity) {\n            demerits = Math.pow(options.demerits.line + badness, 2) - Math.pow(node.penalty, 2); // All other cases\n          } else {\n            demerits = Math.pow(options.demerits.line + badness, 2);\n          }\n\n          if (node.type === 'penalty' && nodes[active.data.position].type === 'penalty') {\n            demerits += options.demerits.flagged * node.flagged * nodes[active.data.position].flagged;\n          } // Calculate the fitness class for this candidate active node.\n\n\n          if (ratio < -0.5) {\n            currentClass = 0;\n          } else if (ratio <= 0.5) {\n            currentClass = 1;\n          } else if (ratio <= 1) {\n            currentClass = 2;\n          } else {\n            currentClass = 3;\n          } // Add a fitness penalty to the demerits if the fitness classes of two adjacent lines\n          // differ too much.\n\n\n          if (Math.abs(currentClass - active.data.fitnessClass) > 1) {\n            demerits += options.demerits.fitness;\n          } // Add the total demerits of the active node to get the total demerits of this candidate node.\n\n\n          demerits += active.data.demerits; // Only store the best candidate for each fitness class\n\n          if (demerits < candidates[currentClass].demerits) {\n            candidates[currentClass] = {\n              active: active,\n              demerits: demerits,\n              ratio: ratio\n            };\n          }\n        }\n\n        active = next; // Stop iterating through active nodes to insert new candidate active nodes in the active list\n        // before moving on to the active nodes for the next line.\n        // TODO: The Knuth and Plass paper suggests a conditional for currentLine < j0. This means paragraphs\n        // with identical line lengths will not be sorted by line number. Find out if that is a desirable outcome.\n        // For now I left this out, as it only adds minimal overhead to the algorithm and keeping the active node\n        // list sorted has a higher priority.\n\n        if (active !== null && active.data.line >= currentLine) {\n          break;\n        }\n      }\n\n      tmpSum = computeSum(index);\n\n      for (fitnessClass = 0; fitnessClass < candidates.length; fitnessClass += 1) {\n        candidate = candidates[fitnessClass];\n\n        if (candidate.demerits < Infinity) {\n          newNode = new LinkedList.Node(breakpoint(index, candidate.demerits, candidate.ratio, candidate.active.data.line + 1, fitnessClass, tmpSum, candidate.active));\n\n          if (active !== null) {\n            activeNodes.insertBefore(active, newNode);\n          } else {\n            activeNodes.push(newNode);\n          }\n        }\n      }\n    }\n  } // Add an active node for the start of the paragraph.\n\n\n  activeNodes.push(new LinkedList.Node(breakpoint(0, 0, 0, 0, 0, undefined, null))); // eslint-disable-next-line no-shadow\n\n  nodes.forEach(function (node, index, nodes) {\n    if (node.type === 'box') {\n      sum.width += node.width;\n    } else if (node.type === 'glue') {\n      if (index > 0 && nodes[index - 1].type === 'box') {\n        mainLoop(node, index, nodes);\n      }\n\n      sum.width += node.width;\n      sum.stretch += node.stretch;\n      sum.shrink += node.shrink;\n    } else if (node.type === 'penalty' && node.penalty !== linebreak.infinity) {\n      mainLoop(node, index, nodes);\n    }\n  });\n\n  if (activeNodes.size() !== 0) {\n    // Find the best active node (the one with the least total demerits.)\n    activeNodes.forEach(function (node) {\n      if (node.data.demerits < tmp.data.demerits) {\n        tmp = node;\n      }\n    });\n\n    while (tmp !== null) {\n      breaks.push({\n        position: tmp.data.position,\n        ratio: tmp.data.ratio\n      });\n      tmp = tmp.data.previous;\n    }\n\n    return breaks.reverse();\n  }\n\n  return [];\n};\n\nlinebreak.infinity = 10000;\n\nlinebreak.glue = function (width, value, stretch, shrink) {\n  return {\n    type: 'glue',\n    value: value,\n    width: width,\n    stretch: stretch,\n    shrink: shrink\n  };\n};\n\nlinebreak.box = function (width, value, hyphenated) {\n  if (hyphenated === void 0) {\n    hyphenated = false;\n  }\n\n  return {\n    type: 'box',\n    width: width,\n    value: value,\n    hyphenated: hyphenated\n  };\n};\n\nlinebreak.penalty = function (width, penalty, flagged) {\n  return {\n    type: 'penalty',\n    width: width,\n    penalty: penalty,\n    flagged: flagged\n  };\n};\n/**\n * Add scalar to run\n *\n * @param  {number}  scalar\n * @param  {Object}  run\n * @return {Object} added run\n */\n\n\nvar add = function add(n, run) {\n  var start = run.start + n;\n  var end = run.end + n;\n  return Object.assign({}, run, {\n    start: start,\n    end: end\n  });\n};\n/**\n * Get run length\n *\n * @param  {Object}  run\n * @return {number} length\n */\n\n\nvar length = function length(run) {\n  return run.end - run.start;\n};\n/**\n * Concats two runs into one\n *\n * @param  {Object}  first run\n * @param  {Object}  second run\n * @return {Object}  concatenated run\n */\n\n\nvar concat = function concat(runA, runB) {\n  var end = runA.end + length(runB);\n  var glyphs = (runA.glyphs || []).concat(runB.glyphs || []);\n  var positions = (runA.positions || []).concat(runB.positions || []);\n  var attributes = Object.assign({}, runA.attributes, runB.attributes);\n  var runAIndices = runA.glyphIndices || [];\n  var runALastIndex = last(runAIndices) || 0;\n  var runBIndices = (runB.glyphIndices || []).map(function (i) {\n    return i + runALastIndex + 1;\n  });\n  var glyphIndices = normalize(runAIndices.concat(runBIndices));\n  return Object.assign({}, runA, {\n    end: end,\n    glyphs: glyphs,\n    positions: positions,\n    attributes: attributes,\n    glyphIndices: glyphIndices\n  });\n};\n/**\n * Insert glyph to run in the given index\n *\n * @param  {number}  string index\n * @param  {Object}  glyph\n * @param  {Object}  run\n * @return {Object}  run with glyph\n */\n\n\nvar insertGlyph$1 = function insertGlyph(index, glyph, run) {\n  if (!glyph) return run; // Split resolves ligature splitting in case new glyph breaks some\n\n  var leadingRun = slice$1(0, index, run);\n  var trailingRun = slice$1(index, Infinity, run);\n  return concat(append$1(glyph, leadingRun), trailingRun);\n};\n/**\n * Insert either glyph or code point to run in the given index\n *\n * @param  {number}  string index\n * @param  {Object | number}  glyph | codePoint\n * @param  {Object}  run\n * @return {Object}  run with glyph\n */\n\n\nvar insert = function insert(index, value, run) {\n  var font = getFont(run);\n  var glyph = isNumber(value) ? fromCodePoint(value, font) : value;\n  return insertGlyph$1(index, glyph, run);\n};\n/**\n * Get run index at char index\n *\n * @param  {number}  char index\n * @param  {Object}  attributedString\n * @return {number} run index\n */\n\n\nvar runIndexAt = function runIndexAt(n, string) {\n  return runIndexAt$1(n, string.runs);\n};\n/**\n * Insert glyph into attributed string\n *\n * @param {number} index\n * @param {Object} glyph\n * @param {Object} attributed string\n * @return {Object} attributed string with new glyph\n */\n\n\nvar insertGlyph = function insertGlyph(index, glyph, attributedString) {\n  var runIndex = runIndexAt(index, attributedString); // Add glyph to the end if run index invalid\n\n  if (runIndex === -1) return append(glyph, attributedString);\n  var codePoints = (glyph === null || glyph === void 0 ? void 0 : glyph.codePoints) || [];\n  var string = attributedString.string.slice(0, index) + stringFromCodePoints(codePoints) + attributedString.string.slice(index);\n  var runs = attributedString.runs.map(function (run, i) {\n    if (i === runIndex) return insert(index - run.start, glyph, run);\n    if (i > runIndex) return add(codePoints.length, run);\n    return run;\n  });\n  return Object.assign({}, attributedString, {\n    string: string,\n    runs: runs\n  });\n};\n/**\n * Advance width between two string indices\n *\n * @param  {number}  start glyph index\n * @param  {number}  end glyph index\n * @param  {Object}  run\n * @return {Object} advanced width run\n */\n\n\nvar advanceWidthBetween$1 = function advanceWidthBetween(start, end, run) {\n  var runStart = run.start || 0;\n  var glyphStartIndex = Math.max(0, glyphIndexAt(start - runStart, run));\n  var glyphEndIndex = Math.max(0, glyphIndexAt(end - runStart, run));\n  var positions = (run.positions || []).slice(glyphStartIndex, glyphEndIndex);\n  return advanceWidth$2(positions);\n};\n/**\n * Advance width between start and end\n * Does not consider ligature splitting for the moment.\n * Check performance impact on supporting this\n *\n * @param  {number}  start offset\n * @param  {number}  end offset\n * @param  {Object}  attributedString\n * @return {number} advance width\n */\n\n\nvar advanceWidthBetween = function advanceWidthBetween(start, end, attributedString) {\n  var runs = filter(start, end, attributedString.runs);\n  return runs.reduce(function (acc, run) {\n    return acc + advanceWidthBetween$1(start, end, run);\n  }, 0);\n};\n\nvar HYPHEN = 0x002d;\nvar TOLERANCE_STEPS = 5;\nvar TOLERANCE_LIMIT = 50;\nvar opts = {\n  width: 3,\n  stretch: 6,\n  shrink: 9\n};\n/**\n * Slice attributed string to many lines\n *\n * @param {Object} attributed string\n * @param  {Array}  nodes\n * @param  {Array}  breaks\n * @return {Array} attributed strings\n */\n\nvar breakLines = function breakLines(string, nodes, breaks) {\n  var start = 0;\n  var end = null;\n  var lines = breaks.reduce(function (acc, breakPoint) {\n    var node = nodes[breakPoint.position];\n    var prevNode = nodes[breakPoint.position - 1]; // Last breakpoint corresponds to K&P mandatory final glue\n\n    if (breakPoint.position === nodes.length - 1) return acc;\n    var line;\n\n    if (node.type === 'penalty') {\n      end = prevNode.value.end;\n      line = slice(start, end, string);\n      line = insertGlyph(line.length, HYPHEN, line);\n    } else {\n      end = node.value.end;\n      line = slice(start, end, string);\n    }\n\n    start = end;\n    return [].concat(acc, [line]);\n  }, []); // Last line\n\n  lines.push(slice(start, string.string.length, string));\n  return lines;\n};\n/**\n * Return Knuth & Plass nodes based on line and previously calculated syllables\n *\n * @param {Object} attributed string\n * @param  {Object}  attributed string\n * @param  {Object}  layout options\n * @return {Array} attributed strings\n */\n\n\nvar getNodes = function getNodes(attributedString, _ref, options) {\n  var align = _ref.align;\n  var start = 0;\n  var hyphenWidth = 5;\n  var syllables = attributedString.syllables;\n  var hyphenPenalty = options.hyphenationPenalty || (align === 'justify' ? 100 : 600);\n  var result = syllables.reduce(function (acc, s, index) {\n    var width = advanceWidthBetween(start, start + s.length, attributedString);\n\n    if (s.trim() === '') {\n      var stretch = width * opts.width / opts.stretch;\n      var shrink = width * opts.width / opts.shrink;\n      var value = {\n        start: start,\n        end: start + s.length\n      };\n      acc.push(linebreak.glue(width, value, stretch, shrink));\n    } else {\n      var hyphenated = syllables[index + 1] !== ' ';\n      var _value = {\n        start: start,\n        end: start + s.length\n      };\n      acc.push(linebreak.box(width, _value, hyphenated));\n\n      if (syllables[index + 1] && hyphenated) {\n        acc.push(linebreak.penalty(hyphenWidth, hyphenPenalty, 1));\n      }\n    }\n\n    start += s.length;\n    return acc;\n  }, []);\n  result.push(linebreak.glue(0, null, linebreak.infinity, 0));\n  result.push(linebreak.penalty(0, -linebreak.infinity, 1));\n  return result;\n};\n\nvar getStyles = function getStyles(attributedString) {\n  var _attributedString$run, _attributedString$run2;\n\n  return ((_attributedString$run = attributedString.runs) === null || _attributedString$run === void 0 ? void 0 : (_attributedString$run2 = _attributedString$run[0]) === null || _attributedString$run2 === void 0 ? void 0 : _attributedString$run2.attributes) || {};\n};\n/**\n * Performs Knuth & Plass line breaking algorithm\n * Fallbacks to best fit algorithm if latter not successful\n *\n * @param  {Object}  layout options\n * @param  {Object}  attributed string\n * @param {Object} attributed string\n * @return {Array} attributed strings\n */\n\n\nvar linebreaker = function linebreaker(options) {\n  return function (attributedString, availableWidths) {\n    var tolerance = options.tolerance || 4;\n    var style = getStyles(attributedString);\n    var nodes = getNodes(attributedString, style, options);\n    var breaks = linebreak(nodes, availableWidths, {\n      tolerance: tolerance\n    }); // Try again with a higher tolerance if the line breaking failed.\n\n    while (breaks.length === 0 && tolerance < TOLERANCE_LIMIT) {\n      tolerance += TOLERANCE_STEPS;\n      breaks = linebreak(nodes, availableWidths, {\n        tolerance: tolerance\n      });\n    }\n\n    if (breaks.length === 0 || breaks.length === 1 && breaks[0].position === 0) {\n      breaks = applyBestFit(nodes, availableWidths);\n    }\n\n    return breakLines(attributedString, nodes, breaks.slice(1));\n  };\n};\n\nvar WHITESPACE_PRIORITY = 1;\nvar LETTER_PRIORITY = 2;\nvar EXPAND_WHITESPACE_FACTOR = {\n  before: 0.5,\n  after: 0.5,\n  priority: WHITESPACE_PRIORITY,\n  unconstrained: false\n};\nvar EXPAND_CHAR_FACTOR = {\n  before: 0.14453125,\n  // 37/256\n  after: 0.14453125,\n  priority: LETTER_PRIORITY,\n  unconstrained: false\n};\nvar SHRINK_WHITESPACE_FACTOR = {\n  before: -0.04296875,\n  // -11/256\n  after: -0.04296875,\n  priority: WHITESPACE_PRIORITY,\n  unconstrained: false\n};\nvar SHRINK_CHAR_FACTOR = {\n  before: -0.04296875,\n  after: -0.04296875,\n  priority: LETTER_PRIORITY,\n  unconstrained: false\n};\n\nvar getCharFactor = function getCharFactor(direction, options) {\n  var expandCharFactor = options.expandCharFactor || {};\n  var shrinkCharFactor = options.shrinkCharFactor || {};\n  return direction === 'GROW' ? Object.assign({}, EXPAND_CHAR_FACTOR, expandCharFactor) : Object.assign({}, SHRINK_CHAR_FACTOR, shrinkCharFactor);\n};\n\nvar getWhitespaceFactor = function getWhitespaceFactor(direction, options) {\n  var expandWhitespaceFactor = options.expandWhitespaceFactor || {};\n  var shrinkWhitespaceFactor = options.shrinkWhitespaceFactor || {};\n  return direction === 'GROW' ? Object.assign({}, EXPAND_WHITESPACE_FACTOR, expandWhitespaceFactor) : Object.assign({}, SHRINK_WHITESPACE_FACTOR, shrinkWhitespaceFactor);\n};\n\nvar factor = function factor(direction, options) {\n  return function (glyphs) {\n    var charFactor = getCharFactor(direction, options);\n    var whitespaceFactor = getWhitespaceFactor(direction, options);\n    var factors = [];\n\n    for (var index = 0; index < glyphs.length; index += 1) {\n      var f = void 0;\n      var glyph = glyphs[index];\n\n      if (isWhiteSpace(glyph)) {\n        f = Object.assign({}, whitespaceFactor);\n\n        if (index === glyphs.length - 1) {\n          f.before = 0;\n\n          if (index > 0) {\n            factors[index - 1].after = 0;\n          }\n        }\n      } else if (glyph.isMark && index > 0) {\n        f = Object.assign({}, factors[index - 1]);\n        f.before = 0;\n        factors[index - 1].after = 0;\n      } else {\n        f = Object.assign({}, charFactor);\n      }\n\n      factors.push(f);\n    }\n\n    return factors;\n  };\n};\n\nvar getFactors = function getFactors(gap, line, options) {\n  var direction = gap > 0 ? 'GROW' : 'SHRINK';\n  var getFactor = factor(direction, options);\n  var factors = line.runs.reduce(function (acc, run) {\n    return acc.concat(getFactor(run.glyphs));\n  }, []);\n  factors[0].before = 0;\n  factors[factors.length - 1].after = 0;\n  return factors;\n};\n/* eslint-disable no-multi-assign */\n\n\nvar KASHIDA_PRIORITY = 0;\nvar NULL_PRIORITY = 3;\n\nvar getDistances = function getDistances(gap, factors) {\n  var total = 0;\n  var priorities = [];\n  var unconstrained = [];\n\n  for (var _priority = KASHIDA_PRIORITY; _priority <= NULL_PRIORITY; _priority += 1) {\n    priorities[_priority] = unconstrained[_priority] = 0;\n  } // sum the factors at each priority\n\n\n  for (var j = 0; j < factors.length; j += 1) {\n    var f = factors[j];\n    var sum = f.before + f.after;\n    total += sum;\n    priorities[f.priority] += sum;\n\n    if (f.unconstrained) {\n      unconstrained[f.priority] += sum;\n    }\n  } // choose the priorities that need to be applied\n\n\n  var highestPriority = -1;\n  var highestPrioritySum = 0;\n  var remainingGap = gap;\n  var priority;\n\n  for (priority = KASHIDA_PRIORITY; priority <= NULL_PRIORITY; priority += 1) {\n    var prioritySum = priorities[priority];\n\n    if (prioritySum !== 0) {\n      if (highestPriority === -1) {\n        highestPriority = priority;\n        highestPrioritySum = prioritySum;\n      } // if this priority covers the remaining gap, we're done\n\n\n      if (Math.abs(remainingGap) <= Math.abs(prioritySum)) {\n        priorities[priority] = remainingGap / prioritySum;\n        unconstrained[priority] = 0;\n        remainingGap = 0;\n        break;\n      } // mark that we need to use 100% of the adjustment from\n      // this priority, and subtract the space that it consumes\n\n\n      priorities[priority] = 1;\n      remainingGap -= prioritySum; // if this priority has unconstrained glyphs, let them consume the remaining space\n\n      if (unconstrained[priority] !== 0) {\n        unconstrained[priority] = remainingGap / unconstrained[priority];\n        remainingGap = 0;\n        break;\n      }\n    }\n  } // zero out remaining priorities (if any)\n\n\n  for (var p = priority + 1; p <= NULL_PRIORITY; p += 1) {\n    priorities[p] = 0;\n    unconstrained[p] = 0;\n  } // if there is still space left over, assign it to the highest priority that we saw.\n  // this violates their factors, but it only happens in extreme cases\n\n\n  if (remainingGap > 0 && highestPriority > -1) {\n    priorities[highestPriority] = (highestPrioritySum + (gap - total)) / highestPrioritySum;\n  } // create and return an array of distances to add to each glyph's advance\n\n\n  var distances = [];\n\n  for (var index = 0; index < factors.length; index += 1) {\n    // the distance to add to this glyph is the sum of the space to add\n    // after this glyph, and the space to add before the next glyph\n    var _f = factors[index];\n    var next = factors[index + 1];\n    var dist = _f.after * priorities[_f.priority];\n\n    if (next) {\n      dist += next.before * priorities[next.priority];\n    } // if this glyph is unconstrained, add the unconstrained distance as well\n\n\n    if (_f.unconstrained) {\n      dist += _f.after * unconstrained[_f.priority];\n\n      if (next) {\n        dist += next.before * unconstrained[next.priority];\n      }\n    }\n\n    distances.push(dist);\n  }\n\n  return distances;\n};\n/**\n * Adjust run positions by given distances\n *\n * @param {Array} distances\n * @param {Object} line\n * @returns {Object} line\n */\n\n\nvar justifyLine = function justifyLine(distances, line) {\n  var index = 0;\n\n  for (var _iterator = _createForOfIteratorHelperLoose(line.runs), _step; !(_step = _iterator()).done;) {\n    var run = _step.value;\n\n    for (var _iterator2 = _createForOfIteratorHelperLoose(run.positions), _step2; !(_step2 = _iterator2()).done;) {\n      var position = _step2.value;\n      position.xAdvance += distances[index++];\n    }\n  }\n\n  return line;\n};\n/**\n * A JustificationEngine is used by a Typesetter to perform line fragment\n * justification. This implementation is based on a description of Apple's\n * justification algorithm from a PDF in the Apple Font Tools package.\n *\n * //TODO: Make it immutable\n *\n * @param {Object} layout options\n * @param {Object} line\n * @returns {Object} line\n */\n\n\nvar justification = function justification(options) {\n  return function (line) {\n    var gap = line.box.width - advanceWidth(line);\n    if (gap === 0) return; // Exact fit\n\n    var factors = getFactors(gap, line, options);\n    var distances = getDistances(gap, factors);\n    return justifyLine(distances, line);\n  };\n};\n/**\n * Returns attributed string ascent\n *\n * @param {Object} attributed string\n * @return {number} ascent\n */\n\n\nvar ascent = function ascent(attributeString) {\n  var reducer = function reducer(acc, run) {\n    return Math.max(acc, ascent$1(run));\n  };\n\n  return attributeString.runs.reduce(reducer, 0);\n};\n/* eslint-disable no-param-reassign */\n\n\nvar BASE_FONT_SIZE = 12;\n/**\n * A TextDecorationEngine is used by a Typesetter to generate\n * DecorationLines for a line fragment, including underlines\n * and strikes.\n */\n\nvar textDecoration = function textDecoration() {\n  return function (lineFragment) {\n    var x = lineFragment.overflowLeft || 0;\n    var overflowRight = lineFragment.overflowRight || 0;\n    var maxX = advanceWidth(lineFragment) - overflowRight;\n    lineFragment.decorationLines = [];\n\n    for (var i = 0; i < lineFragment.runs.length; i += 1) {\n      var run = lineFragment.runs[i];\n      var width = Math.min(maxX - x, advanceWidth$1(run));\n      var thickness = Math.max(0.5, Math.floor(run.attributes.fontSize / BASE_FONT_SIZE));\n\n      if (run.attributes.underline) {\n        var rect = {\n          x: x,\n          y: ascent(lineFragment) + thickness * 2,\n          width: width,\n          height: thickness\n        };\n        var line = {\n          rect: rect,\n          opacity: run.attributes.opacity,\n          color: run.attributes.underlineColor || 'black',\n          style: run.attributes.underlineStyle || 'solid'\n        };\n        lineFragment.decorationLines.push(line);\n      }\n\n      if (run.attributes.strike) {\n        var y = ascent(lineFragment) - ascent$1(run) / 3;\n        var _rect = {\n          x: x,\n          y: y,\n          width: width,\n          height: thickness\n        };\n        var _line = {\n          rect: _rect,\n          opacity: run.attributes.opacity,\n          color: run.attributes.strikeColor || 'black',\n          style: run.attributes.strikeStyle || 'solid'\n        };\n        lineFragment.decorationLines.push(_line);\n      }\n\n      x += width;\n    }\n\n    return lineFragment;\n  };\n};\n\nvar ignoredScripts = ['Common', 'Inherited', 'Unknown'];\n/**\n * Resolves unicode script in runs, grouping equal runs together\n *\n * @param  {Object}  layout options\n * @param  {Object}  attributed string\n * @return {Object} attributed string\n */\n\nvar scriptItemizer = function scriptItemizer() {\n  return function (attributedString) {\n    var string = attributedString.string;\n    var lastScript = 'Unknown';\n    var lastIndex = 0;\n    var index = 0;\n    var res = [];\n    if (!string) return empty();\n\n    for (var i = 0; i < string.length; i += 1) {\n      var char = string[i];\n      var codePoint = char.codePointAt();\n      var script = unicode.getScript(codePoint);\n\n      if (script !== lastScript && !ignoredScripts.includes(script)) {\n        if (lastScript !== 'Unknown') {\n          res.push({\n            start: lastIndex,\n            end: index,\n            attributes: {\n              script: lastScript\n            }\n          });\n        }\n\n        lastIndex = index;\n        lastScript = script;\n      }\n\n      index += char.length;\n    }\n\n    if (lastIndex < string.length) {\n      res.push({\n        start: lastIndex,\n        end: string.length,\n        attributes: {\n          script: lastScript\n        }\n      });\n    }\n\n    return {\n      string: string,\n      runs: res\n    };\n  };\n};\n\nvar SOFT_HYPHEN = \"\\xAD\";\nvar hyphenator = hyphen(pattern);\n\nvar splitHyphen = function splitHyphen(word) {\n  return word.split(SOFT_HYPHEN);\n};\n\nvar cache = {};\n\nvar getParts = function getParts(word) {\n  var base = word.includes(SOFT_HYPHEN) ? word : hyphenator(word);\n  return splitHyphen(base);\n};\n\nvar wordHyphenation = function wordHyphenation() {\n  return function (word) {\n    var cacheKey = \"_\" + word;\n    if (isNil(word)) return [];\n    if (cache[cacheKey]) return cache[cacheKey];\n    cache[cacheKey] = getParts(word);\n    return cache[cacheKey];\n  };\n};\n\nvar getFontSize = function getFontSize(value) {\n  return value.attributes.fontSize || 12;\n};\n/**\n * Resolve font runs in an AttributedString, grouping equal\n * runs and performing font substitution where necessary.\n *\n * @param  {Object}  layout options\n * @param  {Object}  attributed string\n * @return {Object} attributed string\n */\n\n\nvar fontSubstitution = function fontSubstitution() {\n  return function (attributedString) {\n    var string = attributedString.string,\n        runs = attributedString.runs;\n    var lastFont = null;\n    var lastIndex = 0;\n    var index = 0;\n    var res = [];\n    if (!string) return empty();\n\n    for (var _iterator = _createForOfIteratorHelperLoose(runs), _step; !(_step = _iterator()).done;) {\n      var run = _step.value;\n\n      var _fontSize = getFontSize(run);\n\n      var defaultFont = run.attributes.font;\n\n      if (string.length === 0) {\n        res.push({\n          start: 0,\n          end: 0,\n          attributes: {\n            font: defaultFont\n          }\n        });\n        break;\n      }\n\n      for (var _iterator2 = _createForOfIteratorHelperLoose(string.slice(run.start, run.end)), _step2; !(_step2 = _iterator2()).done;) {\n        var char = _step2.value;\n        var font = defaultFont;\n\n        if (font !== lastFont) {\n          if (lastFont) {\n            res.push({\n              start: lastIndex,\n              end: index,\n              attributes: {\n                font: lastFont,\n                scale: lastFont ? _fontSize / lastFont.unitsPerEm : 0\n              }\n            });\n          }\n\n          lastFont = font;\n          lastIndex = index;\n        }\n\n        index += char.length;\n      }\n    }\n\n    if (lastIndex < string.length) {\n      var fontSize = getFontSize(last(runs));\n      res.push({\n        start: lastIndex,\n        end: string.length,\n        attributes: {\n          font: lastFont,\n          scale: lastFont ? fontSize / lastFont.unitsPerEm : 0\n        }\n      });\n    }\n\n    return {\n      string: string,\n      runs: res\n    };\n  };\n};\n\nexport { layoutEngine as default, fontSubstitution, justification, linebreaker, scriptItemizer, textDecoration, wordHyphenation };","map":{"version":3,"names":["isNil","last","dropLast","dropLast$2","adjust","compose","_extends","_objectWithoutPropertiesLoose","_createForOfIteratorHelperLoose","unicode","hyphen","pattern","fromFragments","fragments","offset","string","runs","forEach","fragment","push","start","end","length","attributes","defaultHyphenationEngine","word","wrapWords","engines","options","attributedString","_engines$wordHyphenat","_engines","syllables","hyphenateWord","hyphenationCallback","wordHyphenation","call","i","run","words","slice","split","filter","Boolean","j","parts","apply","join","copy","rect","Object","assign","partition","height","a","b","y","crop","_partition","result","height$2","paragraph","reduce","acc","block","box","calculateScale","_attributes$font","fontSize","unitsPerEm","font","scale","_run$attributes","index","glyphIndices","value","getFont","slice$2","glyph","codePoints","String","fromCodePoint","layout","glyphs","glyphIndexAt","_run$glyphIndices","normalize","array","head","map","slice$1","_run$glyphs","_run$glyphs2","runScale","startIndex","endIndex","startGlyph","endGlyph","startOffset","startGlyphs","Infinity","endOffset","endGlyphs","sliceStart","Math","min","glyphPosition","g","xAdvance","advanceWidth","startPositions","positions","endPositions","flat","runIndexAt$1","runIndexAt","n","findIndex","max","subtract","sliceRuns","sliceFirstRun","sliceLastRun","isFirst","isLast","filteredRuns","slicedRuns","findCharIndex","search","findLastCharIndex","match","lastIndexOf","trim","empty$1","empty","isNumber","appendIndices","indices","lastIndex","newIndices","Array","fill","concat","glyphForCodePoint","appendGlyph","_glyph$codePoints","glyphLength","append$1","append","stringFromCodePoints","codePointsString","firstRuns","lastRun","ELLIPSIS_UNICODE","ELLIPSIS_STRING","fromCharCode","getEllipsisCodePoint","encode","_font$encode","parseInt","truncate","_last","_last2","_last2$attributes","_Object$assign","codePoint","lastBlock","omit","ascent$1","ascent","_run$attributes$attac","_run$attributes2","_run$attributes2$font","attachmentHeight","attachment","fontAscent","descent","_run$attributes$font","fontDescent","lineGap","height$1","lineHeight","attributeString","reducer","intersects","x","num1","width","num2","_excluded","getLineFragment","lineRect","excludeRect","eStart","eEnd","lStart","lEnd","r","getLineFragments","excludeRects","_loop","pieces","generateLineRects","container","lineRects","maxY","currentRect","rest","lineRectFragments","ATTACHMENT_CODE$1","purgeAttachments","shouldPurge","includes","layoutLines","rects","lines","indent","shift","currentY","line","_line$runs","_line$runs$","lineIndent","style","newLine","layoutParagraph","_paragraph$runs","_paragraph$runs$","_paragraph$runs$$attr","availableWidths","linebreaker","sliceAtHeight","newBlock","counter","typesetter","attributedStrings","blocks","paragraphs","layoutBlock","maxLines","truncateEllipsis","truncateMode","linesCount","paragraphRect","nextParagraph","slicedBlock","linesHeight","shouldTruncate","DUMMY_CODEPOINT","resolve","next","getCharacterSpacing","characterSpacing","scalePositions","position","xSpacing","yAdvance","xOffset","yOffset","layoutRun","runString","glyphRun","generateGlyphs","resolveRunYOffset","p","resolveYOffset","sort","isEmpty","sortPoints","generatePoints","mergeRuns","groupEmptyRuns","groups","values","flattenEmptyRuns","flattenRegularRuns","res","points","attrs","stack","_points$i","type","splice","flatten","emptyRuns","regularRuns","omitFont","preprocessRuns","fontSubstitution","scriptItemizer","_omitFont","omittedFontRuns","_fontSubstitution","substitutedRuns","_scriptItemizer","itemizationRuns","length$1","splitParagraphs","breakPoint","indexOf","advanceWidth$2","pos","advanceWidth$1","WHITE_SPACES_CODE","isWhiteSpace","leadingPositions","leadingWhitespaces","leadingOffset$1","leadingOffset","reverse","trailingPositions","trailingOffset$1","trailingOffset","dropLast$1","ALIGNMENT_FACTORS","center","right","removeNewLine","getOverflowLeft","overflowLeft","getOverflowRight","overflowRight","adjustOverflow","justifyLine$1","justifyLine","align","lineWidth","alignFactor","remainingWidth","shouldJustify","justification","finalizeLine","lineAscent","lineDescent","lineXAdvance","descent$1","finalizeBlock","isLastFragment","alignLastLine","textDecoration","finalizeFragments","blockFinalizer","ATTACHMENT_CODE","isReplaceGlyph","resolveRunAttachments","resolveAttachments","applyAttributes","backgroundColor","bidiLevel","bullet","color","features","hangingPunctuation","hyphenationFactor","justificationFactor","lineSpacing","link","marginLeft","margin","marginRight","opacity","paddingTop","padding","paragraphSpacing","underline","underlineColor","underlineStyle","script","shrinkFactor","strike","strikeColor","strikeStyle","stroke","wordSpacing","applyRunStyles","applyDefaultStyles","layoutEngine","processParagraph","processParagraphs","INFINITY","getNextBreakpoint","subnodes","widths","lineNumber","minimumBadness","sum","stretch","shrink","lineLength","calculateRatio","node","ratio","penalty","badness","pow","abs","applyBestFit","nodes","count","breakpoints","breakpoint","Node","data","prev","_proto","prototype","toString","LinkedList","tail","listSize","_proto2","isLinked","size","first","toArray","fun","contains","at","listLength","insertAfter","newNode","insertBefore","unshift","remove","pop","linebreak","settings","demerits","flagged","fitness","tolerance","activeNodes","lineLengths","breaks","tmp","fitnessClass","totals","previous","computeCost","active","currentLine","infinity","computeSum","breakPointIndex","mainLoop","candidates","tmpSum","currentClass","candidate","undefined","glue","hyphenated","add","runA","runB","runAIndices","runALastIndex","runBIndices","insertGlyph$1","insertGlyph","leadingRun","trailingRun","insert","runIndex","advanceWidthBetween$1","advanceWidthBetween","runStart","glyphStartIndex","glyphEndIndex","HYPHEN","TOLERANCE_STEPS","TOLERANCE_LIMIT","opts","breakLines","prevNode","getNodes","_ref","hyphenWidth","hyphenPenalty","hyphenationPenalty","s","_value","getStyles","_attributedString$run","_attributedString$run2","WHITESPACE_PRIORITY","LETTER_PRIORITY","EXPAND_WHITESPACE_FACTOR","before","after","priority","unconstrained","EXPAND_CHAR_FACTOR","SHRINK_WHITESPACE_FACTOR","SHRINK_CHAR_FACTOR","getCharFactor","direction","expandCharFactor","shrinkCharFactor","getWhitespaceFactor","expandWhitespaceFactor","shrinkWhitespaceFactor","factor","charFactor","whitespaceFactor","factors","f","isMark","getFactors","gap","getFactor","KASHIDA_PRIORITY","NULL_PRIORITY","getDistances","total","priorities","_priority","highestPriority","highestPrioritySum","remainingGap","prioritySum","distances","_f","dist","_iterator","_step","done","_iterator2","_step2","BASE_FONT_SIZE","lineFragment","maxX","decorationLines","thickness","floor","_rect","_line","ignoredScripts","lastScript","char","codePointAt","getScript","SOFT_HYPHEN","hyphenator","splitHyphen","cache","getParts","base","cacheKey","getFontSize","lastFont","_fontSize","defaultFont","default"],"sources":["C:/Users/Rahul Gupta/git/lockerroom345website/lockerroom345website/frontend/node_modules/@react-pdf/textkit/lib/textkit.es.js"],"sourcesContent":["import { isNil, last, dropLast as dropLast$2, adjust, compose } from '@react-pdf/fns';\nimport _extends from '@babel/runtime/helpers/extends';\nimport _objectWithoutPropertiesLoose from '@babel/runtime/helpers/objectWithoutPropertiesLoose';\nimport _createForOfIteratorHelperLoose from '@babel/runtime/helpers/createForOfIteratorHelperLoose';\nimport unicode from 'unicode-properties';\nimport hyphen from 'hyphen';\nimport pattern from 'hyphen/patterns/en-us';\n\n/**\n * Create attributed string from text fragments\n *\n * @param  {Array}  fragments\n * @return {Object} attributed string\n */\nvar fromFragments = function fromFragments(fragments) {\n  var offset = 0;\n  var string = '';\n  var runs = [];\n  fragments.forEach(function (fragment) {\n    string += fragment.string;\n    runs.push({\n      start: offset,\n      end: offset + fragment.string.length,\n      attributes: fragment.attributes || {}\n    });\n    offset += fragment.string.length;\n  });\n  return {\n    string: string,\n    runs: runs\n  };\n};\n\n/**\n * Default word hyphenation engine used when no one provided.\n * Does not perform word hyphenation at all\n *\n * @param  {String} word\n * @return {Array} same word\n */\n\nvar defaultHyphenationEngine = function defaultHyphenationEngine(word) {\n  return [word];\n};\n/**\n * Wrap words of attribute string\n *\n * @param  {Object} layout engines\n * @param  {Object}  layout options\n * @param  {Object}  attributed string\n * @return {Object} attributed string including syllables\n */\n\n\nvar wrapWords = function wrapWords(engines, options) {\n  if (engines === void 0) {\n    engines = {};\n  }\n\n  if (options === void 0) {\n    options = {};\n  }\n\n  return function (attributedString) {\n    var _engines$wordHyphenat, _engines;\n\n    var syllables = [];\n    var fragments = [];\n    var hyphenateWord = options.hyphenationCallback || ((_engines$wordHyphenat = (_engines = engines).wordHyphenation) === null || _engines$wordHyphenat === void 0 ? void 0 : _engines$wordHyphenat.call(_engines, options)) || defaultHyphenationEngine;\n\n    for (var i = 0; i < attributedString.runs.length; i += 1) {\n      var string = '';\n      var run = attributedString.runs[i];\n      var words = attributedString.string.slice(run.start, run.end).split(/([ ]+)/g).filter(Boolean);\n\n      for (var j = 0; j < words.length; j += 1) {\n        var word = words[j];\n        var parts = hyphenateWord(word);\n        syllables.push.apply(syllables, parts);\n        string += parts.join('');\n      }\n\n      fragments.push({\n        string: string,\n        attributes: run.attributes\n      });\n    }\n\n    return _extends({}, fromFragments(fragments), {\n      syllables: syllables\n    });\n  };\n};\n\n/**\n * Clone rect\n *\n * @param  {Object}  rect\n * @return {Object} cloned rect\n */\nvar copy = function copy(rect) {\n  return Object.assign({}, rect);\n};\n\nvar partition = function partition(rect, height) {\n  var a = Object.assign({}, rect, {\n    height: height\n  });\n  var b = Object.assign({}, rect, {\n    y: rect.y + height,\n    height: rect.height - height\n  });\n  return [a, b];\n};\n\n/**\n * Crop upper section of rect\n *\n * @param  {Object}  rect\n * @return {Object} cropped rect\n */\n\nvar crop = function crop(height, rect) {\n  var _partition = partition(rect, height),\n      result = _partition[1];\n\n  return result;\n};\n\n/**\n * Get paragraph block height\n *\n * @param  {Object}  paragraph block\n * @return {number} paragraph block height\n */\nvar height$2 = function height(paragraph) {\n  return paragraph.reduce(function (acc, block) {\n    return acc + block.box.height;\n  }, 0);\n};\n\n/**\n * Calculate run scale\n *\n * @param  {Object}  run\n * @return {number} scale\n */\nvar calculateScale = function calculateScale(run) {\n  var _attributes$font;\n\n  var attributes = run.attributes || {};\n  var fontSize = attributes.fontSize || 12;\n  var unitsPerEm = (_attributes$font = attributes.font) === null || _attributes$font === void 0 ? void 0 : _attributes$font.unitsPerEm;\n  return unitsPerEm ? fontSize / unitsPerEm : 0;\n};\n/**\n * Get run scale\n *\n * @param  {Object}  run\n * @return {number} scale\n */\n\n\nvar scale = function scale(run) {\n  var _run$attributes;\n\n  return ((_run$attributes = run.attributes) === null || _run$attributes === void 0 ? void 0 : _run$attributes.scale) || calculateScale(run);\n};\n\n/**\n * Get ligature offset by index\n *\n * Ex. ffi ligature\n *\n *   glyphs:         l  o  f  f  i  m\n *   glyphIndices:   0  1  2  2  2  3\n *   offset:         0  0  0  1  2  0\n *\n * @param  {number}  index\n * @param  {Object}  run\n * @return {number} ligature offset\n */\nvar offset = function offset(index, run) {\n  if (!run) return 0;\n  var glyphIndices = run.glyphIndices || [];\n  var value = glyphIndices[index];\n  return glyphIndices.slice(0, index).filter(function (i) {\n    return i === value;\n  }).length;\n};\n\n/**\n * Get run font\n *\n * @param  {Object}  run\n * @return {Object} font\n */\nvar getFont = function getFont(run) {\n  var _run$attributes;\n\n  return ((_run$attributes = run.attributes) === null || _run$attributes === void 0 ? void 0 : _run$attributes.font) || null;\n};\n\n/**\n * Slice glyph between codePoints range\n * Util for breaking ligatures\n *\n * @param  {number}  start code point index\n * @param  {number}  end code point index\n * @param  {Object}  font to generate new glyph\n * @param  {Object} glyph to be sliced\n * @return {Array} sliced glyph parts\n */\nvar slice$2 = function slice(start, end, font, glyph) {\n  if (!glyph) return [];\n  if (start === end) return [];\n  if (start === 0 && end === glyph.codePoints.length) return [glyph];\n  var codePoints = glyph.codePoints.slice(start, end);\n  var string = String.fromCodePoint.apply(String, codePoints);\n  return font ? font.layout(string).glyphs : [glyph];\n};\n\n/**\n * Return glyph index at string index, if glyph indices present.\n * Otherwise return string index\n *\n * @param  {number}  string index\n * @param  {Object}  run\n * @return {number}  glyph index\n */\n\nvar glyphIndexAt = function glyphIndexAt(index, run) {\n  var _run$glyphIndices;\n\n  var result = run === null || run === void 0 ? void 0 : (_run$glyphIndices = run.glyphIndices) === null || _run$glyphIndices === void 0 ? void 0 : _run$glyphIndices[index];\n  return isNil(result) ? index : result;\n};\n\n/**\n * Returns new array starting with zero, and keeping same relation between consecutive values\n *\n * @param  {Array[number]}  list\n * @return {boolean} normalized array\n */\nvar normalize = function normalize(array) {\n  var head = array[0];\n  return array.map(function (value) {\n    return value - head;\n  });\n};\n\n/**\n * Slice run between glyph indices range\n *\n * @param  {number}  start glyph index\n * @param  {number}  end glyph index\n * @param  {Object}  run\n * @return {Object} sliced run\n */\n\nvar slice$1 = function slice(start, end, run) {\n  var _run$glyphs, _run$glyphs2;\n\n  var runScale = scale(run);\n  var font = getFont(run); // Get glyph start and end indices\n\n  var startIndex = glyphIndexAt(start, run);\n  var endIndex = glyphIndexAt(end, run); // Get start and end glyph\n\n  var startGlyph = (_run$glyphs = run.glyphs) === null || _run$glyphs === void 0 ? void 0 : _run$glyphs[startIndex];\n  var endGlyph = (_run$glyphs2 = run.glyphs) === null || _run$glyphs2 === void 0 ? void 0 : _run$glyphs2[endIndex]; // Get start ligature chunks (if any)\n\n  var startOffset = offset(start, run);\n  var startGlyphs = startOffset > 0 ? slice$2(startOffset, Infinity, font, startGlyph) : []; // Get end ligature chunks (if any)\n\n  var endOffset = offset(end, run);\n  var endGlyphs = slice$2(0, endOffset, font, endGlyph); // Compute new glyphs\n\n  var sliceStart = startIndex + Math.min(1, startOffset);\n  var glyphs = (run.glyphs || []).slice(sliceStart, endIndex); // Compute new positions\n\n  var glyphPosition = function glyphPosition(g) {\n    return {\n      xAdvance: g.advanceWidth * runScale\n    };\n  };\n\n  var startPositions = startGlyphs.map(glyphPosition);\n  var positions = (run.positions || []).slice(sliceStart, endIndex);\n  var endPositions = endGlyphs.map(glyphPosition);\n  return Object.assign({}, run, {\n    start: run.start + start,\n    end: Math.min(run.end, run.start + end),\n    glyphIndices: normalize((run.glyphIndices || []).slice(start, end)),\n    glyphs: [startGlyphs, glyphs, endGlyphs].flat(),\n    positions: [startPositions, positions, endPositions].flat()\n  });\n};\n\n/**\n * Get run index that contains passed index\n *\n * @param  {number}  char index\n * @param  {Array}  runs array\n * @return {Array} run index\n */\nvar runIndexAt$1 = function runIndexAt(n, runs) {\n  if (!runs) return -1;\n  return runs.findIndex(function (run) {\n    return run.start <= n && n < run.end;\n  });\n};\n\n/**\n * Filter runs contained between start and end\n *\n * @param  {number}  start\n * @param  {number}  end\n * @param  {Array}  runs\n * @return {boolean} filtered runs\n */\n\nvar filter = function filter(start, end, runs) {\n  var startIndex = runIndexAt$1(start, runs);\n  var endIndex = Math.max(runIndexAt$1(end - 1, runs), startIndex);\n  return runs.slice(startIndex, endIndex + 1);\n};\n\n/**\n * Subtract scalar to run\n *\n * @param  {number}  scalar\n * @param  {Object}  run\n * @return {Object} subtracted run\n */\nvar subtract = function subtract(n, run) {\n  var start = run.start - n;\n  var end = run.end - n;\n  return Object.assign({}, run, {\n    start: start,\n    end: end\n  });\n};\n\n/**\n * Slice array of runs\n *\n * @param  {number}  start offset\n * @param  {number}  end offset\n * @param  {Array}  runs\n * @return {Array} sliced runs\n */\n\nvar sliceRuns = function sliceRuns(start, end, runs) {\n  var sliceFirstRun = function sliceFirstRun(a) {\n    return slice$1(start - a.start, end - a.start, a);\n  };\n\n  var sliceLastRun = function sliceLastRun(a) {\n    return slice$1(0, end - a.start, a);\n  };\n\n  return runs.map(function (run, i) {\n    var result = run;\n    var isFirst = i === 0;\n    var isLast = !isFirst && i === runs.length - 1;\n    if (isFirst) result = sliceFirstRun(run);\n    if (isLast) result = sliceLastRun(run);\n    return subtract(start, result);\n  });\n};\n/**\n * Slice attributed string between two indices\n *\n * @param  {number}  start offset\n * @param  {number}  end offset\n * @param  {Object}  attributedString\n * @return {Object} attributedString\n */\n\n\nvar slice = function slice(start, end, attributedString) {\n  if (attributedString.string.length === 0) return attributedString;\n  var string = attributedString.string.slice(start, end);\n  var filteredRuns = filter(start, end, attributedString.runs);\n  var slicedRuns = sliceRuns(start, end, filteredRuns);\n  return Object.assign({}, attributedString, {\n    string: string,\n    runs: slicedRuns\n  });\n};\n\nvar findCharIndex = function findCharIndex(string) {\n  return string.search(/\\S/g);\n};\n\nvar findLastCharIndex = function findLastCharIndex(string) {\n  var match = string.match(/\\S/g);\n  return match ? string.lastIndexOf(match[match.length - 1]) : -1;\n};\n/**\n * Removes (strips) whitespace from both ends of the attributted string.\n *\n * @param  {Object}  attributedString\n * @return {Object} attributedString\n */\n\n\nvar trim = function trim(attributedString) {\n  var start = findCharIndex(attributedString.string);\n  var end = findLastCharIndex(attributedString.string);\n  return slice(start, end + 1, attributedString);\n};\n\n/**\n * Returns empty run\n *\n * @return {Object} empty run\n */\nvar empty$1 = function empty() {\n  return {\n    start: 0,\n    end: 0,\n    glyphIndices: [],\n    glyphs: [],\n    positions: [],\n    attributes: {}\n  };\n};\n\nvar isNumber = function isNumber(value) {\n  return typeof value === 'number';\n};\n\n/**\n * Append glyph indices with given length\n *\n * Ex. appendIndices(3, [0, 1, 2, 2]) => [0, 1, 2, 2, 3, 3, 3]\n *\n * @param  {number}  length\n * @param  {Array}  glyph indices\n * @return {Array}  extended glyph indices\n */\n\nvar appendIndices = function appendIndices(length, indices) {\n  var lastIndex = last(indices);\n  var value = isNil(lastIndex) ? 0 : lastIndex + 1;\n  var newIndices = Array(length).fill(value);\n  return indices.concat(newIndices);\n};\n\n/**\n * Get glyph for a given code point\n *\n * @param  {number}  codePoint\n * @param  {Object}  font\n * @return {Object}  glyph\n * */\nvar fromCodePoint = function fromCodePoint(value, font) {\n  return font && value ? font.glyphForCodePoint(value) : null;\n};\n\n/**\n * Append glyph to run\n *\n * @param  {Object}  glyph\n * @param  {Object}  run\n * @return {Object} run with glyph\n */\n\nvar appendGlyph = function appendGlyph(glyph, run) {\n  var _glyph$codePoints;\n\n  var glyphLength = ((_glyph$codePoints = glyph.codePoints) === null || _glyph$codePoints === void 0 ? void 0 : _glyph$codePoints.length) || 0;\n  var end = run.end + glyphLength;\n  var glyphs = run.glyphs.concat(glyph);\n  var glyphIndices = appendIndices(glyphLength, run.glyphIndices);\n  if (!run.positions) return Object.assign({}, run, {\n    end: end,\n    glyphs: glyphs,\n    glyphIndices: glyphIndices\n  });\n  var positions = run.positions.concat({\n    xAdvance: glyph.advanceWidth * scale(run)\n  });\n  return Object.assign({}, run, {\n    end: end,\n    glyphs: glyphs,\n    glyphIndices: glyphIndices,\n    positions: positions\n  });\n};\n/**\n * Append glyph or code point to run\n *\n * @param  {Object | number}  glyph | codePoint\n * @param  {Object}  run\n * @return {Object} run with glyph\n */\n\n\nvar append$1 = function append(value, run) {\n  if (!value) return run;\n  var font = getFont(run);\n  var glyph = isNumber(value) ? fromCodePoint(value, font) : value;\n  return appendGlyph(glyph, run);\n};\n\n/**\n * Get string from array of code points\n *\n * @param {Array} code points\n * @return {String} string\n */\nvar stringFromCodePoints = function stringFromCodePoints(codePoints) {\n  return String.fromCodePoint.apply(String, codePoints);\n};\n\n/**\n * Append glyph into last run of attributed string\n *\n * @param {Object} glyph\n * @param {Object} attributed string\n * @return {Object} attributed string with new glyph\n */\n\nvar append = function append(glyph, attributedString) {\n  var codePoints = (glyph === null || glyph === void 0 ? void 0 : glyph.codePoints) || [];\n  var codePointsString = stringFromCodePoints(codePoints);\n  var string = attributedString.string + codePointsString;\n  var firstRuns = attributedString.runs.slice(0, -1);\n  var lastRun = last(attributedString.runs) || empty$1();\n  var runs = firstRuns.concat(append$1(glyph, lastRun));\n  return Object.assign({}, attributedString, {\n    string: string,\n    runs: runs\n  });\n};\n\nvar ELLIPSIS_UNICODE = 8230;\nvar ELLIPSIS_STRING = String.fromCharCode(ELLIPSIS_UNICODE);\n/**\n * Get ellipsis codepoint. This may be different in standard and embedded fonts\n *\n * @param  {number}  font\n * @return {Object} ellipsis codepoint\n */\n\nvar getEllipsisCodePoint = function getEllipsisCodePoint(font) {\n  if (!font.encode) return ELLIPSIS_UNICODE;\n\n  var _font$encode = font.encode(ELLIPSIS_STRING),\n      codePoints = _font$encode[0];\n\n  return parseInt(codePoints[0], 16);\n};\n/**\n * Trucante block with ellipsis\n *\n * @param  {number}  lines quantity\n * @param  {Object}  paragraph block\n * @return {Object} sliced paragraph block\n */\n\n\nvar truncate = function truncate(block) {\n  var _last, _last2, _last2$attributes;\n\n  var runs = ((_last = last(block)) === null || _last === void 0 ? void 0 : _last.runs) || [];\n  var font = (_last2 = last(runs)) === null || _last2 === void 0 ? void 0 : (_last2$attributes = _last2.attributes) === null || _last2$attributes === void 0 ? void 0 : _last2$attributes.font;\n\n  if (font) {\n    var _Object$assign;\n\n    var index = block.length - 1;\n    var codePoint = getEllipsisCodePoint(font);\n    var glyph = font.glyphForCodePoint(codePoint);\n    var lastBlock = append(glyph, trim(block[index]));\n    return Object.assign([], block, (_Object$assign = {}, _Object$assign[index] = lastBlock, _Object$assign));\n  }\n\n  return block;\n};\n\n/**\n * Omit attribute from run\n *\n * @param  {Object}  run\n * @return {Object} run without ommited attribute\n */\nvar omit = function omit(value, run) {\n  var attributes = Object.assign({}, run.attributes);\n  delete attributes[value];\n  return Object.assign({}, run, {\n    attributes: attributes\n  });\n};\n\n/**\n * Get run ascent\n *\n * @param  {Object}  run\n * @return {boolean} ascent\n */\n\nvar ascent$1 = function ascent(run) {\n  var _run$attributes, _run$attributes$attac, _run$attributes2, _run$attributes2$font;\n\n  var attachmentHeight = ((_run$attributes = run.attributes) === null || _run$attributes === void 0 ? void 0 : (_run$attributes$attac = _run$attributes.attachment) === null || _run$attributes$attac === void 0 ? void 0 : _run$attributes$attac.height) || 0;\n  var fontAscent = ((_run$attributes2 = run.attributes) === null || _run$attributes2 === void 0 ? void 0 : (_run$attributes2$font = _run$attributes2.font) === null || _run$attributes2$font === void 0 ? void 0 : _run$attributes2$font.ascent) || 0;\n  return Math.max(attachmentHeight, fontAscent * scale(run));\n};\n\n/**\n * Get run descent\n *\n * @param  {Object}  run\n * @return {number} descent\n */\n\nvar descent = function descent(run) {\n  var _run$attributes, _run$attributes$font;\n\n  var fontDescent = ((_run$attributes = run.attributes) === null || _run$attributes === void 0 ? void 0 : (_run$attributes$font = _run$attributes.font) === null || _run$attributes$font === void 0 ? void 0 : _run$attributes$font.descent) || 0;\n  return scale(run) * fontDescent;\n};\n\n/**\n * Get run lineGap\n *\n * @param  {Object}  run\n * @return {number} lineGap\n */\n\nvar lineGap = function lineGap(run) {\n  var _run$attributes, _run$attributes$font;\n\n  return (((_run$attributes = run.attributes) === null || _run$attributes === void 0 ? void 0 : (_run$attributes$font = _run$attributes.font) === null || _run$attributes$font === void 0 ? void 0 : _run$attributes$font.lineGap) || 0) * scale(run);\n};\n\n/**\n * Get run height\n *\n * @param  {Object}  run\n * @return {number} height\n */\n\nvar height$1 = function height(run) {\n  var _run$attributes;\n\n  var lineHeight = (_run$attributes = run.attributes) === null || _run$attributes === void 0 ? void 0 : _run$attributes.lineHeight;\n  return lineHeight || lineGap(run) + ascent$1(run) - descent(run);\n};\n\n/**\n * Returns attributed string height\n *\n * @param {Object} attributed string\n * @return {number} height\n */\n\nvar height = function height(attributeString) {\n  var reducer = function reducer(acc, run) {\n    return Math.max(acc, height$1(run));\n  };\n\n  return attributeString.runs.reduce(reducer, 0);\n};\n\n/**\n * Checks if two rects intersect each other\n *\n * @param {Rect} a\n * @param {Rect} b\n * @returns {Boolean} rects intersects\n */\nvar intersects = function intersects(a, b) {\n  var x = Math.max(a.x, b.x);\n  var num1 = Math.min(a.x + a.width, b.x + b.width);\n  var y = Math.max(a.y, b.y);\n  var num2 = Math.min(a.y + a.height, b.y + b.height);\n  return num1 >= x && num2 >= y;\n};\n\nvar _excluded = [\"excludeRects\"];\n\nvar getLineFragment = function getLineFragment(lineRect, excludeRect) {\n  if (!intersects(excludeRect, lineRect)) return [lineRect];\n  var eStart = excludeRect.x;\n  var eEnd = excludeRect.x + excludeRect.width;\n  var lStart = lineRect.x;\n  var lEnd = lineRect.x + lineRect.width;\n  var a = Object.assign({}, lineRect, {\n    width: eStart - lStart\n  });\n  var b = Object.assign({}, lineRect, {\n    x: eEnd,\n    width: lEnd - eEnd\n  });\n  return [a, b].filter(function (r) {\n    return r.width > 0;\n  });\n};\n\nvar getLineFragments = function getLineFragments(rect, excludeRects) {\n  var fragments = [rect];\n\n  var _loop = function _loop(i) {\n    var excludeRect = excludeRects[i];\n    fragments = fragments.reduce(function (acc, fragment) {\n      var pieces = getLineFragment(fragment, excludeRect);\n      return acc.concat(pieces);\n    }, []);\n  };\n\n  for (var i = 0; i < excludeRects.length; i += 1) {\n    _loop(i);\n  }\n\n  return fragments;\n};\n\nvar generateLineRects = function generateLineRects(container, height) {\n  var excludeRects = container.excludeRects,\n      rect = _objectWithoutPropertiesLoose(container, _excluded);\n\n  if (!excludeRects) return [rect];\n  var lineRects = [];\n  var maxY = Math.max.apply(Math, excludeRects.map(function (r) {\n    return r.y + r.height;\n  }));\n  var currentRect = rect;\n\n  while (currentRect.y < maxY) {\n    var _partition = partition(currentRect, height),\n        lineRect = _partition[0],\n        rest = _partition[1];\n\n    var lineRectFragments = getLineFragments(lineRect, excludeRects);\n    currentRect = rest;\n    lineRects.push.apply(lineRects, lineRectFragments);\n  }\n\n  return [].concat(lineRects, [currentRect]);\n};\n\nvar ATTACHMENT_CODE$1 = \"\\uFFFC\"; // 65532\n\n/**\n * Remove attachment attribute if no char present\n *\n * @param  {Object} attributed string\n * @return {Object} attributed string\n */\n\nvar purgeAttachments = function purgeAttachments(attributedString) {\n  var shouldPurge = !attributedString.string.includes(ATTACHMENT_CODE$1);\n  if (!shouldPurge) return attributedString;\n  var runs = attributedString.runs.map(function (run) {\n    return omit('attachment', run);\n  });\n  return Object.assign({}, attributedString, {\n    runs: runs\n  });\n};\n/**\n * Layout paragraphs inside rectangle\n *\n * @param  {Object} rect\n * @param  {Array} attributed strings\n * @return {Object} layout blocks\n */\n\n\nvar layoutLines = function layoutLines(rects, lines, indent) {\n  var rect = rects.shift();\n  var currentY = rect.y;\n  return lines.map(function (line, i) {\n    var _line$runs, _line$runs$;\n\n    var lineIndent = i === 0 ? indent : 0;\n    var style = ((_line$runs = line.runs) === null || _line$runs === void 0 ? void 0 : (_line$runs$ = _line$runs[0]) === null || _line$runs$ === void 0 ? void 0 : _line$runs$.attributes) || {};\n    var height$1 = Math.max(height(line), style.lineHeight);\n\n    if (currentY + height$1 > rect.y + rect.height && rects.length > 0) {\n      rect = rects.shift();\n      currentY = rect.y;\n    }\n\n    var newLine = Object.assign({}, line);\n    delete newLine.syllables;\n    newLine.box = {\n      x: rect.x + lineIndent,\n      y: currentY,\n      width: rect.width - lineIndent,\n      height: height$1\n    };\n    currentY += height$1;\n    return purgeAttachments(newLine);\n  });\n};\n/**\n * Performs line breaking and layout\n *\n * @param  {Object} engines\n * @param  {Object}  layout options\n * @param  {Object} rect\n * @param  {Object} attributed string\n * @return {Object} layout block\n */\n\n\nvar layoutParagraph = function layoutParagraph(engines, options) {\n  return function (container, paragraph) {\n    var _paragraph$runs, _paragraph$runs$, _paragraph$runs$$attr;\n\n    var height$1 = height(paragraph);\n    var indent = ((_paragraph$runs = paragraph.runs) === null || _paragraph$runs === void 0 ? void 0 : (_paragraph$runs$ = _paragraph$runs[0]) === null || _paragraph$runs$ === void 0 ? void 0 : (_paragraph$runs$$attr = _paragraph$runs$.attributes) === null || _paragraph$runs$$attr === void 0 ? void 0 : _paragraph$runs$$attr.indent) || 0;\n    var rects = generateLineRects(container, height$1);\n    var availableWidths = rects.map(function (r) {\n      return r.width;\n    });\n    availableWidths[0] -= indent;\n    var lines = engines.linebreaker(options)(paragraph, availableWidths);\n    return layoutLines(rects, lines, indent);\n  };\n};\n\n/**\n * Slice block at given height\n *\n * @param  {number}  height\n * @param  {Object}  paragraph block\n * @return {number} sliced paragraph block\n */\nvar sliceAtHeight = function sliceAtHeight(height, block) {\n  var newBlock = [];\n  var counter = 0;\n\n  for (var i = 0; i < block.length; i += 1) {\n    var line = block[i];\n    counter += line.box.height;\n\n    if (counter < height) {\n      newBlock.push(line);\n    } else {\n      break;\n    }\n  }\n\n  return newBlock;\n};\n\n/**\n * Layout paragraphs inside container until it does not\n * fit anymore, performing line wrapping in the process.\n *\n * @param  {Object}  engines\n * @param  {Object}  layout options\n * @param  {Object}  container rect\n * @param  {Object}  attributed strings (paragraphs)\n * @return {Array} paragraph blocks\n */\n\nvar typesetter = function typesetter(engines, options, container) {\n  return function (attributedStrings) {\n    var blocks = [];\n    var paragraphs = [].concat(attributedStrings);\n    var layoutBlock = layoutParagraph(engines, options);\n    var maxLines = isNil(container.maxLines) ? Infinity : container.maxLines;\n    var truncateEllipsis = container.truncateMode === 'ellipsis';\n    var linesCount = maxLines;\n    var paragraphRect = copy(container);\n    var nextParagraph = paragraphs.shift();\n\n    while (linesCount > 0 && nextParagraph) {\n      var block = layoutBlock(paragraphRect, nextParagraph);\n      var slicedBlock = block.slice(0, linesCount);\n      var linesHeight = height$2(slicedBlock);\n      var shouldTruncate = truncateEllipsis && block.length !== slicedBlock.length;\n      linesCount -= slicedBlock.length;\n\n      if (paragraphRect.height >= linesHeight) {\n        blocks.push(shouldTruncate ? truncate(slicedBlock) : slicedBlock);\n        paragraphRect = crop(linesHeight, paragraphRect);\n        nextParagraph = paragraphs.shift();\n      } else {\n        blocks.push(truncate(sliceAtHeight(paragraphRect.height, slicedBlock)));\n        break;\n      }\n    }\n\n    return blocks;\n  };\n};\n\nvar DUMMY_CODEPOINT = 123;\n/**\n * Resolve string indices based on glyphs code points\n *\n * @param  {Array}  glyphs\n * @return {Array} glyph indices\n */\n\nvar resolve = function resolve(glyphs) {\n  if (glyphs === void 0) {\n    glyphs = [];\n  }\n\n  return glyphs.reduce(function (acc, glyph) {\n    var codePoints = (glyph === null || glyph === void 0 ? void 0 : glyph.codePoints) || [DUMMY_CODEPOINT];\n    if (acc.length === 0) return codePoints.map(function () {\n      return 0;\n    });\n    var last = acc[acc.length - 1];\n    var next = codePoints.map(function () {\n      return last + 1;\n    });\n    return [].concat(acc, next);\n  }, []);\n};\n\nvar getCharacterSpacing = function getCharacterSpacing(run) {\n  var _run$attributes;\n\n  return ((_run$attributes = run.attributes) === null || _run$attributes === void 0 ? void 0 : _run$attributes.characterSpacing) || 0;\n};\n/**\n * Scale run positions\n *\n * @param  {Object}  run\n * @param  {Array}  positions\n * @return {Array} scaled positions\n */\n\n\nvar scalePositions = function scalePositions(run, positions) {\n  var runScale = scale(run);\n  var characterSpacing = getCharacterSpacing(run);\n  return positions.map(function (position, i) {\n    var isLast = i === positions.length;\n    var xSpacing = isLast ? 0 : characterSpacing;\n    return Object.assign({}, position, {\n      xAdvance: position.xAdvance * runScale + xSpacing,\n      yAdvance: position.yAdvance * runScale,\n      xOffset: position.xOffset * runScale,\n      yOffset: position.yOffset * runScale\n    });\n  });\n};\n/**\n * Create glyph run\n *\n * @param  {String}  string\n * @param  {Object}  run\n * @return {Object}  glyph run\n */\n\n\nvar layoutRun = function layoutRun(string) {\n  return function (run) {\n    var start = run.start,\n        end = run.end,\n        _run$attributes2 = run.attributes,\n        attributes = _run$attributes2 === void 0 ? {} : _run$attributes2;\n    var font = attributes.font;\n    if (!font) return _extends({}, run, {\n      glyphs: [],\n      glyphIndices: [],\n      positions: []\n    });\n    var runString = string.slice(start, end);\n    var glyphRun = font.layout(runString);\n    var positions = scalePositions(run, glyphRun.positions);\n    var glyphIndices = resolve(glyphRun.glyphs);\n    return _extends({}, run, {\n      positions: positions,\n      glyphIndices: glyphIndices,\n      glyphs: glyphRun.glyphs\n    });\n  };\n};\n/**\n * Generate glyphs for single attributed string\n *\n * @param  {Object}  layout engines\n * @param  {Object}  layout options\n * @param  {Array}  attributed strings\n * @return {Array} attributed string with glyphs\n */\n\n\nvar generateGlyphs = function generateGlyphs() {\n  return function (attributedString) {\n    var runs = attributedString.runs.map(layoutRun(attributedString.string));\n    return Object.assign({}, attributedString, {\n      runs: runs\n    });\n  };\n};\n\n/**\n * Resolves yOffset for run\n *\n * @param  {Object}  run\n * @return {Object} run\n */\nvar resolveRunYOffset = function resolveRunYOffset(run) {\n  var _run$attributes, _run$attributes$font, _run$attributes2;\n\n  if (!run.positions) return run;\n  var unitsPerEm = ((_run$attributes = run.attributes) === null || _run$attributes === void 0 ? void 0 : (_run$attributes$font = _run$attributes.font) === null || _run$attributes$font === void 0 ? void 0 : _run$attributes$font.unitsPerEm) || 0;\n  var yOffset = (((_run$attributes2 = run.attributes) === null || _run$attributes2 === void 0 ? void 0 : _run$attributes2.yOffset) || 0) * unitsPerEm;\n  var positions = run.positions.map(function (p) {\n    return Object.assign({}, p, {\n      yOffset: yOffset\n    });\n  });\n  return Object.assign({}, run, {\n    positions: positions\n  });\n};\n/**\n * Resolves yOffset for multiple paragraphs\n *\n * @param  {Object} layout engines\n * @param  {Object}  layout options\n * @param  {Array}  attributed strings (paragraphs)\n * @return {Array} attributed strings (paragraphs)\n */\n\n\nvar resolveYOffset = function resolveYOffset() {\n  return function (attributedString) {\n    var runs = attributedString.runs.map(resolveRunYOffset);\n    return Object.assign({}, attributedString, {\n      runs: runs\n    });\n  };\n};\n\n/**\n * Sort runs in ascending order\n *\n * @param  {Array}  runs\n * @return {Array} sorted runs\n */\nvar sort = function sort(runs) {\n  return runs.sort(function (a, b) {\n    return a.start - b.start || a.end - b.end;\n  });\n};\n\n/**\n * Is run empty (start === end)\n *\n * @param  {Object}  run\n * @return {Object} is run empty\n */\nvar isEmpty = function isEmpty(run) {\n  return run.start === run.end;\n};\n\nvar sortPoints = function sortPoints(a, b) {\n  return a[1] - b[1] || a[3] - b[3];\n};\n\nvar generatePoints = function generatePoints(runs) {\n  var result = runs.reduce(function (acc, run, i) {\n    return acc.concat([['start', run.start, run.attributes, i], ['end', run.end, run.attributes, i]]);\n  }, []);\n  return result.sort(sortPoints);\n};\n\nvar mergeRuns = function mergeRuns(runs) {\n  return runs.reduce(function (acc, run) {\n    var attributes = Object.assign({}, acc.attributes, run.attributes);\n    return Object.assign({}, run, {\n      attributes: attributes\n    });\n  }, {});\n};\n\nvar groupEmptyRuns = function groupEmptyRuns(runs) {\n  var groups = runs.reduce(function (acc, run) {\n    if (!acc[run.start]) acc[run.start] = [];\n    acc[run.start].push(run);\n    return acc;\n  }, {});\n  return Object.values(groups);\n};\n\nvar flattenEmptyRuns = function flattenEmptyRuns(runs) {\n  return groupEmptyRuns(runs).map(mergeRuns);\n};\n\nvar flattenRegularRuns = function flattenRegularRuns(runs) {\n  var res = [];\n  var points = generatePoints(runs);\n  var start = -1;\n  var attrs = {};\n  var stack = [];\n\n  for (var i = 0; i < points.length; i += 1) {\n    var _points$i = points[i],\n        type = _points$i[0],\n        offset = _points$i[1],\n        attributes = _points$i[2];\n\n    if (start !== -1 && start < offset) {\n      res.push({\n        start: start,\n        end: offset,\n        attributes: attrs\n      });\n    }\n\n    if (type === 'start') {\n      stack.push(attributes);\n      attrs = Object.assign({}, attrs, attributes);\n    } else {\n      attrs = {};\n\n      for (var j = 0; j < stack.length; j += 1) {\n        if (stack[j] === attributes) {\n          // eslint-disable-next-line no-plusplus\n          stack.splice(j--, 1);\n        } else {\n          attrs = Object.assign({}, attrs, stack[j]);\n        }\n      }\n    }\n\n    start = offset;\n  }\n\n  return res;\n};\n/**\n * Flatten many runs\n *\n * @param  {Array}  runs\n * @return {Array} flatten runs\n */\n\n\nvar flatten = function flatten(runs) {\n  if (runs === void 0) {\n    runs = [];\n  }\n\n  var emptyRuns = flattenEmptyRuns(runs.filter(function (run) {\n    return isEmpty(run);\n  }));\n  var regularRuns = flattenRegularRuns(runs.filter(function (run) {\n    return !isEmpty(run);\n  }));\n  return sort(emptyRuns.concat(regularRuns));\n};\n\n/**\n * Returns empty attributed string\n *\n * @return {Object} empty attributed string\n */\nvar empty = function empty() {\n  return {\n    string: '',\n    runs: []\n  };\n};\n\nvar omitFont = function omitFont(attributedString) {\n  var runs = attributedString.runs.map(function (run) {\n    return omit('font', run);\n  });\n  return Object.assign({}, attributedString, {\n    runs: runs\n  });\n};\n/**\n * Performs font substitution and script itemization on attributed string\n *\n * @param  {Object}  engines\n * @param  {Object}  layout options\n * @param  {Object}  attributed string\n * @return {Object} processed attributed string\n */\n\n\nvar preprocessRuns = function preprocessRuns(engines, options) {\n  return function (attributedString) {\n    if (isNil(attributedString)) return empty();\n    var string = attributedString.string;\n    var fontSubstitution = engines.fontSubstitution,\n        scriptItemizer = engines.scriptItemizer;\n\n    var _omitFont = omitFont(attributedString),\n        omittedFontRuns = _omitFont.runs;\n\n    var _fontSubstitution = fontSubstitution(options)(attributedString),\n        substitutedRuns = _fontSubstitution.runs;\n\n    var _scriptItemizer = scriptItemizer(options)(attributedString),\n        itemizationRuns = _scriptItemizer.runs;\n\n    var runs = substitutedRuns.concat(itemizationRuns).concat(omittedFontRuns);\n    return {\n      string: string,\n      runs: flatten(runs)\n    };\n  };\n};\n\n/**\n * Get attributed string start value\n *\n * @param  {Object}  attributed string\n * @return {number} start\n */\nvar start = function start(attributedString) {\n  var runs = attributedString.runs;\n  return runs.length === 0 ? 0 : runs[0].start;\n};\n\n/**\n * Get attributed string end value\n *\n * @param  {Object}  attributed string\n * @return {number} end\n */\n\nvar end = function end(attributedString) {\n  var runs = attributedString.runs;\n  return runs.length === 0 ? 0 : last(runs).end;\n};\n\n/**\n * Get attributed string length\n *\n * @param  {Object}  glyph string\n * @return {number} end\n */\n\nvar length$1 = function length(attributedString) {\n  return end(attributedString) - start(attributedString);\n};\n\n/**\n * Breaks attributed string into paragraphs\n *\n * @param  {Object}  engines\n * @param  {Object}  layout options\n * @param  {Object}  attributed string\n * @return {Array} attributed string array\n */\n\nvar splitParagraphs = function splitParagraphs() {\n  return function (attributedString) {\n    var res = [];\n    var start = 0;\n    var breakPoint = attributedString.string.indexOf('\\n') + 1;\n\n    while (breakPoint > 0) {\n      res.push(slice(start, breakPoint, attributedString));\n      start = breakPoint;\n      breakPoint = attributedString.string.indexOf('\\n', breakPoint) + 1;\n    }\n\n    if (start === 0) {\n      res.push(attributedString);\n    } else if (start < attributedString.string.length) {\n      res.push(slice(start, length$1(attributedString), attributedString));\n    }\n\n    return res;\n  };\n};\n\n/**\n * Return positions advance width\n *\n * @param  {Object}  positions\n * @return {number} advance width\n */\nvar advanceWidth$2 = function advanceWidth(positions) {\n  return positions.reduce(function (acc, pos) {\n    return acc + (pos.xAdvance || 0);\n  }, 0);\n};\n\n/**\n * Return run advance width\n *\n * @param  {Object}  run\n * @return {number} advance width\n */\n\nvar advanceWidth$1 = function advanceWidth(run) {\n  return advanceWidth$2(run.positions || []);\n};\n\n/**\n * Returns attributed string advancewidth\n *\n * @param {Object} attributed string\n * @return {number} advance width\n */\n\nvar advanceWidth = function advanceWidth(attributeString) {\n  var reducer = function reducer(acc, run) {\n    return acc + advanceWidth$1(run);\n  };\n\n  return attributeString.runs.reduce(reducer, 0);\n};\n\nvar WHITE_SPACES_CODE = 32;\n/**\n * Check if glyph is white space\n *\n * @param  {Object}  glyph\n * @return {Boolean}  is white space\n * */\n\nvar isWhiteSpace = function isWhiteSpace(glyph) {\n  var codePoints = (glyph === null || glyph === void 0 ? void 0 : glyph.codePoints) || [];\n  return codePoints.includes(WHITE_SPACES_CODE);\n};\n\n/**\n * Get white space leading positions\n *\n * @param  {Object}  run\n * @return {Array} white space leading positions\n */\n\nvar leadingPositions = function leadingPositions(run) {\n  var glyphs = run.glyphs || [];\n  var positions = run.positions || [];\n  var leadingWhitespaces = glyphs.findIndex(function (g) {\n    return !isWhiteSpace(g);\n  });\n  return positions.slice(0, leadingWhitespaces);\n};\n/**\n * Get run leading white space offset\n *\n * @param  {Object}  run\n * @return {number} leading white space offset\n */\n\n\nvar leadingOffset$1 = function leadingOffset(run) {\n  var positions = leadingPositions(run);\n  return positions.reduce(function (acc, pos) {\n    return acc + (pos.xAdvance || 0);\n  }, 0);\n};\n\n/**\n * Get attributed string leading white space offset\n *\n * @param  {Object}  attributed string\n * @return {number} leading white space offset\n */\n\nvar leadingOffset = function leadingOffset(attributedString) {\n  var runs = attributedString.runs || [];\n  return leadingOffset$1(runs[0]);\n};\n\nvar reverse = function reverse(array) {\n  return [].concat(array).reverse();\n};\n/**\n * Get white space trailing positions\n *\n * @param  {Object}  run\n * @return {Array} white space trailing positions\n */\n\n\nvar trailingPositions = function trailingPositions(run) {\n  var glyphs = reverse(run.glyphs || []);\n  var positions = reverse(run.positions || []);\n  var leadingWhitespaces = glyphs.findIndex(function (g) {\n    return !isWhiteSpace(g);\n  });\n  return positions.slice(0, leadingWhitespaces);\n};\n/**\n * Get run trailing white space offset\n *\n * @param  {Object}  run\n * @return {number} trailing white space offset\n */\n\n\nvar trailingOffset$1 = function trailingOffset(run) {\n  var positions = trailingPositions(run);\n  return positions.reduce(function (acc, pos) {\n    return acc + (pos.xAdvance || 0);\n  }, 0);\n};\n\n/**\n * Get attributed string trailing white space offset\n *\n * @param  {Object}  attributed string\n * @return {number} trailing white space offset\n */\n\nvar trailingOffset = function trailingOffset(attributedString) {\n  var runs = attributedString.runs || [];\n  return trailingOffset$1(last(runs));\n};\n\n/**\n * Drop last char of run\n *\n * @param  {Object}  run\n * @return {boolean} run without last char\n */\n\nvar dropLast$1 = function dropLast(run) {\n  return slice$1(0, run.end - run.start - 1, run);\n};\n\n/**\n * Drop last glyph\n *\n * @param {Object} attributed string\n * @return {Object} attributed string with new glyph\n */\n\nvar dropLast = function dropLast(attributeString) {\n  var string = dropLast$2(attributeString.string);\n  var runs = adjust(-1, dropLast$1, attributeString.runs);\n  return Object.assign({}, attributeString, {\n    string: string,\n    runs: runs\n  });\n};\n\nvar ALIGNMENT_FACTORS = {\n  center: 0.5,\n  right: 1\n};\n/**\n * Remove new line char at the end of line if present\n *\n * @param  {Object}  line\n * @return {Object} line\n */\n\nvar removeNewLine = function removeNewLine(line) {\n  return last(line.string) === '\\n' ? dropLast(line) : line;\n};\n\nvar getOverflowLeft = function getOverflowLeft(line) {\n  return leadingOffset(line) + (line.overflowLeft || 0);\n};\n\nvar getOverflowRight = function getOverflowRight(line) {\n  return trailingOffset(line) + (line.overflowRight || 0);\n};\n/**\n * Ignore whitespace at the start and end of a line for alignment\n *\n * @param  {Object}  line\n * @return {Object} line\n */\n\n\nvar adjustOverflow = function adjustOverflow(line) {\n  var overflowLeft = getOverflowLeft(line);\n  var overflowRight = getOverflowRight(line);\n  var x = line.box.x - overflowLeft;\n  var width = line.box.width + overflowLeft + overflowRight;\n  var box = Object.assign({}, line.box, {\n    x: x,\n    width: width\n  });\n  return Object.assign({}, line, {\n    box: box,\n    overflowLeft: overflowLeft,\n    overflowRight: overflowRight\n  });\n};\n/**\n * Performs line justification by calling appropiate engine\n *\n * @param  {Object}  engines\n * @param  {Object}  layout options\n * @param  {string}  text align\n * @param  {Object}  line\n * @return {Object} line\n */\n\n\nvar justifyLine$1 = function justifyLine(engines, options, align) {\n  return function (line) {\n    var lineWidth = advanceWidth(line);\n    var alignFactor = ALIGNMENT_FACTORS[align] || 0;\n    var remainingWidth = Math.max(0, line.box.width - lineWidth);\n    var shouldJustify = align === 'justify' || lineWidth > line.box.width;\n    var x = line.box.x + remainingWidth * alignFactor;\n    var box = Object.assign({}, line.box, {\n      x: x\n    });\n    var newLine = Object.assign({}, line, {\n      box: box\n    });\n    return shouldJustify ? engines.justification(options)(newLine) : newLine;\n  };\n};\n\nvar finalizeLine = function finalizeLine(line) {\n  var lineAscent = 0;\n  var lineDescent = 0;\n  var lineHeight = 0;\n  var lineXAdvance = 0;\n  var runs = line.runs.map(function (run) {\n    var height = height$1(run);\n    var ascent = ascent$1(run);\n    var descent$1 = descent(run);\n    var xAdvance = advanceWidth$1(run);\n    lineHeight = Math.max(lineHeight, height);\n    lineAscent = Math.max(lineAscent, ascent);\n    lineDescent = Math.max(lineDescent, descent$1);\n    lineXAdvance += xAdvance;\n    return Object.assign({}, run, {\n      height: height,\n      ascent: ascent,\n      descent: descent$1,\n      xAdvance: xAdvance\n    });\n  });\n  return Object.assign({}, line, {\n    runs: runs,\n    height: lineHeight,\n    ascent: lineAscent,\n    descent: lineDescent,\n    xAdvance: lineXAdvance\n  });\n};\n/**\n * Finalize line by performing line justification\n * and text decoration (using appropiate engines)\n *\n * @param  {Object}  engines\n * @param  {Object}  layout options\n * @param  {Object}  line\n * @param  {number}  line index\n * @param  {Array}  total lines\n * @return {Object} line\n */\n\n\nvar finalizeBlock = function finalizeBlock(engines, options) {\n  if (engines === void 0) {\n    engines = {};\n  }\n\n  return function (line, i, lines) {\n    var _line$runs, _line$runs$;\n\n    var isLastFragment = i === lines.length - 1;\n    var style = ((_line$runs = line.runs) === null || _line$runs === void 0 ? void 0 : (_line$runs$ = _line$runs[0]) === null || _line$runs$ === void 0 ? void 0 : _line$runs$.attributes) || {};\n    var align = isLastFragment ? style.alignLastLine : style.align;\n    return compose(finalizeLine, engines.textDecoration(options), justifyLine$1(engines, options, align), adjustOverflow, removeNewLine)(line);\n  };\n};\n/**\n * Finalize line block by performing line justification\n * and text decoration (using appropiate engines)\n *\n * @param  {Object}  engines\n * @param  {Object}  layout options\n * @param  {Array}  line blocks\n * @return {Array} line blocks\n */\n\n\nvar finalizeFragments = function finalizeFragments(engines, options) {\n  return function (blocks) {\n    var blockFinalizer = finalizeBlock(engines, options);\n    return blocks.map(function (block) {\n      return block.map(blockFinalizer);\n    });\n  };\n};\n\nvar ATTACHMENT_CODE = 0xfffc; // 65532\n\nvar isReplaceGlyph = function isReplaceGlyph(glyph) {\n  return glyph.codePoints.includes(ATTACHMENT_CODE);\n};\n/**\n * Resolve attachments of run\n *\n * @param  {Object}  run\n * @return {Object} run\n */\n\n\nvar resolveRunAttachments = function resolveRunAttachments(run) {\n  var _run$attributes;\n\n  if (!run.positions) return run;\n  var glyphs = run.glyphs || [];\n  var attachment = ((_run$attributes = run.attributes) === null || _run$attributes === void 0 ? void 0 : _run$attributes.attachment) || {};\n  var positions = run.positions.map(function (position, i) {\n    var glyph = glyphs[i];\n\n    if (attachment && attachment.width && isReplaceGlyph(glyph)) {\n      return Object.assign({}, position, {\n        xAdvance: attachment.width\n      });\n    }\n\n    return Object.assign({}, position);\n  });\n  return Object.assign({}, run, {\n    positions: positions\n  });\n};\n/**\n * Resolve attachments for multiple paragraphs\n *\n * @param  {Object} layout engines\n * @param  {Object}  layout options\n * @param  {Array}  attributed strings (paragraphs)\n * @return {Array} attributed strings (paragraphs)\n */\n\n\nvar resolveAttachments = function resolveAttachments() {\n  return function (attributedString) {\n    var runs = attributedString.runs.map(resolveRunAttachments);\n    return Object.assign({}, attributedString, {\n      runs: runs\n    });\n  };\n};\n\nvar applyAttributes = function applyAttributes(a) {\n  return {\n    align: a.align || 'left',\n    alignLastLine: a.alignLastLine || (a.align === 'justify' ? 'left' : a.align || 'left'),\n    attachment: a.attachment || null,\n    backgroundColor: a.backgroundColor || null,\n    bidiLevel: a.bidiLevel || null,\n    bullet: a.bullet || null,\n    characterSpacing: a.characterSpacing || 0,\n    color: a.color || 'black',\n    features: a.features || [],\n    fill: a.fill !== false,\n    font: a.font || null,\n    fontSize: a.fontSize || 12,\n    hangingPunctuation: a.hangingPunctuation || false,\n    hyphenationFactor: a.hyphenationFactor || 0,\n    indent: a.indent || 0,\n    justificationFactor: a.justificationFactor || 1,\n    lineHeight: a.lineHeight || null,\n    lineSpacing: a.lineSpacing || 0,\n    link: a.link || null,\n    marginLeft: a.marginLeft || a.margin || 0,\n    marginRight: a.marginRight || a.margin || 0,\n    opacity: a.opacity,\n    paddingTop: a.paddingTop || a.padding || 0,\n    paragraphSpacing: a.paragraphSpacing || 0,\n    underline: a.underline || false,\n    underlineColor: a.underlineColor || a.color || 'black',\n    underlineStyle: a.underlineStyle || 'solid',\n    script: a.script || null,\n    shrinkFactor: a.shrinkFactor || 0,\n    strike: a.strike || false,\n    strikeColor: a.strikeColor || a.color || 'black',\n    strikeStyle: a.strikeStyle || 'solid',\n    stroke: a.stroke || false,\n    wordSpacing: a.wordSpacing || 0,\n    yOffset: a.yOffset || 0\n  };\n};\n/**\n * Apply default style to run\n *\n * @param  {Object}  run\n * @return {Object} run with styles\n */\n\n\nvar applyRunStyles = function applyRunStyles(run) {\n  var attributes = applyAttributes(run.attributes);\n  return Object.assign({}, run, {\n    attributes: attributes\n  });\n};\n/**\n * Apply default attributes for an attributed string\n *\n * @param  {Object}  engines\n * @param  {Object}  layout options\n * @param  {Object}  attributed string\n * @return {Object} attributed string\n */\n\n\nvar applyDefaultStyles = function applyDefaultStyles() {\n  return function (attributedString) {\n    var string = attributedString.string || '';\n    var runs = (attributedString.runs || []).map(applyRunStyles);\n    return {\n      string: string,\n      runs: runs\n    };\n  };\n};\n\n/**\n * A LayoutEngine is the main object that performs text layout.\n * It accepts an AttributedString and a Container object\n * to layout text into, and uses several helper objects to perform\n * various layout tasks. These objects can be overridden to customize\n * layout behavior.\n *\n * @param  {Object}  engines\n * @param  {Object}  attributed string\n * @param  {Object}  container rect\n * @param  {Object}  layout options\n * @return {Array} paragraph blocks\n */\n\nvar layoutEngine = function layoutEngine(engines) {\n  return function (attributedString, container, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    var processParagraph = compose(resolveYOffset(), resolveAttachments(), generateGlyphs(), wrapWords(engines, options));\n\n    var processParagraphs = function processParagraphs(paragraphs) {\n      return paragraphs.map(processParagraph);\n    };\n\n    return compose(finalizeFragments(engines, options), typesetter(engines, options, container), processParagraphs, splitParagraphs(), preprocessRuns(engines, options), applyDefaultStyles())(attributedString);\n  };\n};\n\n/* eslint-disable no-plusplus */\nvar INFINITY = 10000;\n\nvar getNextBreakpoint = function getNextBreakpoint(subnodes, widths, lineNumber) {\n  var position = null;\n  var minimumBadness = Infinity;\n  var sum = {\n    width: 0,\n    stretch: 0,\n    shrink: 0\n  };\n  var lineLength = widths[Math.min(lineNumber, widths.length - 1)];\n\n  var calculateRatio = function calculateRatio(node) {\n    if (sum.width < lineLength) {\n      return sum.stretch - node.stretch > 0 ? (lineLength - sum.width) / sum.stretch : INFINITY;\n    }\n\n    if (sum.width > lineLength) {\n      return sum.shrink - node.shrink > 0 ? (lineLength - sum.width) / sum.shrink : INFINITY;\n    }\n\n    return 0;\n  };\n\n  for (var i = 0; i < subnodes.length; i += 1) {\n    var node = subnodes[i];\n\n    if (node.type === 'box') {\n      sum.width += node.width;\n    } else if (node.type === 'glue') {\n      sum.width += node.width;\n      sum.stretch += node.stretch;\n      sum.shrink += node.shrink;\n    }\n\n    if (sum.width - sum.shrink > lineLength) {\n      if (position === null) {\n        var j = i === 0 ? i + 1 : i;\n\n        while (j < subnodes.length && (subnodes[j].type === 'glue' || subnodes[j].type === 'penalty')) {\n          j++;\n        }\n\n        position = j - 1;\n      }\n\n      break;\n    }\n\n    if (node.type === 'penalty' || node.type === 'glue') {\n      var ratio = calculateRatio(node);\n      var penalty = node.type === 'penalty' ? node.penalty : 0;\n      var badness = 100 * Math.pow(Math.abs(ratio), 3) + penalty;\n\n      if (minimumBadness >= badness) {\n        position = i;\n        minimumBadness = badness;\n      }\n    }\n  }\n\n  return sum.width - sum.shrink > lineLength ? position : null;\n};\n\nvar applyBestFit = function applyBestFit(nodes, widths) {\n  var count = 0;\n  var lineNumber = 0;\n  var subnodes = nodes;\n  var breakpoints = [{\n    position: 0\n  }];\n\n  while (subnodes.length > 0) {\n    var breakpoint = getNextBreakpoint(subnodes, widths, lineNumber);\n\n    if (breakpoint !== null) {\n      count += breakpoint;\n      breakpoints.push({\n        position: count\n      });\n      subnodes = subnodes.slice(breakpoint + 1, subnodes.length);\n      count++;\n      lineNumber++;\n    } else {\n      subnodes = [];\n    }\n  }\n\n  return breakpoints;\n};\n\n/* eslint-disable no-param-reassign */\n\n/* eslint-disable max-classes-per-file */\nvar Node = /*#__PURE__*/function () {\n  function Node(data) {\n    this.prev = null;\n    this.next = null;\n    this.data = data;\n  }\n\n  var _proto = Node.prototype;\n\n  _proto.toString = function toString() {\n    return this.data.toString();\n  };\n\n  return Node;\n}();\n\nvar LinkedList = /*#__PURE__*/function () {\n  function LinkedList() {\n    this.head = null;\n    this.tail = null;\n    this.listSize = 0;\n  }\n\n  var _proto2 = LinkedList.prototype;\n\n  _proto2.isLinked = function isLinked(node) {\n    return !(node && node.prev === null && node.next === null && this.tail !== node && this.head !== node || this.isEmpty());\n  };\n\n  _proto2.size = function size() {\n    return this.listSize;\n  };\n\n  _proto2.isEmpty = function isEmpty() {\n    return this.listSize === 0;\n  };\n\n  _proto2.first = function first() {\n    return this.head;\n  };\n\n  _proto2.last = function last() {\n    return this.last;\n  };\n\n  _proto2.toString = function toString() {\n    return this.toArray().toString();\n  };\n\n  _proto2.toArray = function toArray() {\n    var node = this.head;\n    var result = [];\n\n    while (node !== null) {\n      result.push(node);\n      node = node.next;\n    }\n\n    return result;\n  };\n\n  _proto2.forEach = function forEach(fun) {\n    var node = this.head;\n\n    while (node !== null) {\n      fun(node);\n      node = node.next;\n    }\n  };\n\n  _proto2.contains = function contains(n) {\n    var node = this.head;\n\n    if (!this.isLinked(n)) {\n      return false;\n    }\n\n    while (node !== null) {\n      if (node === n) {\n        return true;\n      }\n\n      node = node.next;\n    }\n\n    return false;\n  };\n\n  _proto2.at = function at(i) {\n    var node = this.head;\n    var index = 0;\n\n    if (i >= this.listLength || i < 0) {\n      return null;\n    }\n\n    while (node !== null) {\n      if (i === index) {\n        return node;\n      }\n\n      node = node.next;\n      index += 1;\n    }\n\n    return null;\n  };\n\n  _proto2.insertAfter = function insertAfter(node, newNode) {\n    if (!this.isLinked(node)) {\n      return this;\n    }\n\n    newNode.prev = node;\n    newNode.next = node.next;\n\n    if (node.next === null) {\n      this.tail = newNode;\n    } else {\n      node.next.prev = newNode;\n    }\n\n    node.next = newNode;\n    this.listSize += 1;\n    return this;\n  };\n\n  _proto2.insertBefore = function insertBefore(node, newNode) {\n    if (!this.isLinked(node)) {\n      return this;\n    }\n\n    newNode.prev = node.prev;\n    newNode.next = node;\n\n    if (node.prev === null) {\n      this.head = newNode;\n    } else {\n      node.prev.next = newNode;\n    }\n\n    node.prev = newNode;\n    this.listSize += 1;\n    return this;\n  };\n\n  _proto2.push = function push(node) {\n    if (this.head === null) {\n      this.unshift(node);\n    } else {\n      this.insertAfter(this.tail, node);\n    }\n\n    return this;\n  };\n\n  _proto2.unshift = function unshift(node) {\n    if (this.head === null) {\n      this.head = node;\n      this.tail = node;\n      node.prev = null;\n      node.next = null;\n      this.listSize += 1;\n    } else {\n      this.insertBefore(this.head, node);\n    }\n\n    return this;\n  };\n\n  _proto2.remove = function remove(node) {\n    if (!this.isLinked(node)) {\n      return this;\n    }\n\n    if (node.prev === null) {\n      this.head = node.next;\n    } else {\n      node.prev.next = node.next;\n    }\n\n    if (node.next === null) {\n      this.tail = node.prev;\n    } else {\n      node.next.prev = node.prev;\n    }\n\n    this.listSize -= 1;\n    return this;\n  };\n\n  _proto2.pop = function pop() {\n    var node = this.tail;\n    this.tail.prev.next = null;\n    this.tail = this.tail.prev;\n    this.listSize -= 1;\n    node.prev = null;\n    node.next = null;\n    return node;\n  };\n\n  _proto2.shift = function shift() {\n    var node = this.head;\n    this.head.next.prev = null;\n    this.head = this.head.next;\n    this.listSize -= 1;\n    node.prev = null;\n    node.next = null;\n    return node;\n  };\n\n  return LinkedList;\n}();\n\nLinkedList.Node = Node;\n\n/* eslint-disable no-restricted-properties */\n/**\n * @preserve Knuth and Plass line breaking algorithm in JavaScript\n *\n * Licensed under the new BSD License.\n * Copyright 2009-2010, Bram Stein\n * All rights reserved.\n */\n\nvar linebreak = function linebreak(nodes, lines, settings) {\n  var options = {\n    demerits: {\n      line: settings && settings.demerits && settings.demerits.line || 10,\n      flagged: settings && settings.demerits && settings.demerits.flagged || 100,\n      fitness: settings && settings.demerits && settings.demerits.fitness || 3000\n    },\n    tolerance: settings && settings.tolerance || 3\n  };\n  var activeNodes = new LinkedList();\n  var sum = {\n    width: 0,\n    stretch: 0,\n    shrink: 0\n  };\n  var lineLengths = lines;\n  var breaks = [];\n  var tmp = {\n    data: {\n      demerits: Infinity\n    }\n  };\n\n  function breakpoint(position, demerits, ratio, line, fitnessClass, totals, previous) {\n    return {\n      position: position,\n      demerits: demerits,\n      ratio: ratio,\n      line: line,\n      fitnessClass: fitnessClass,\n      totals: totals || {\n        width: 0,\n        stretch: 0,\n        shrink: 0\n      },\n      previous: previous\n    };\n  }\n\n  function computeCost(start, end, active, currentLine) {\n    var width = sum.width - active.totals.width;\n    var stretch = 0;\n    var shrink = 0; // If the current line index is within the list of linelengths, use it, otherwise use\n    // the last line length of the list.\n\n    var lineLength = currentLine < lineLengths.length ? lineLengths[currentLine - 1] : lineLengths[lineLengths.length - 1];\n\n    if (nodes[end].type === 'penalty') {\n      width += nodes[end].width;\n    }\n\n    if (width < lineLength) {\n      // Calculate the stretch ratio\n      stretch = sum.stretch - active.totals.stretch;\n\n      if (stretch > 0) {\n        return (lineLength - width) / stretch;\n      }\n\n      return linebreak.infinity;\n    }\n\n    if (width > lineLength) {\n      // Calculate the shrink ratio\n      shrink = sum.shrink - active.totals.shrink;\n\n      if (shrink > 0) {\n        return (lineLength - width) / shrink;\n      }\n\n      return linebreak.infinity;\n    } // perfect match\n\n\n    return 0;\n  } // Add width, stretch and shrink values from the current\n  // break point up to the next box or forced penalty.\n\n\n  function computeSum(breakPointIndex) {\n    var result = {\n      width: sum.width,\n      stretch: sum.stretch,\n      shrink: sum.shrink\n    };\n\n    for (var i = breakPointIndex; i < nodes.length; i += 1) {\n      if (nodes[i].type === 'glue') {\n        result.width += nodes[i].width;\n        result.stretch += nodes[i].stretch;\n        result.shrink += nodes[i].shrink;\n      } else if (nodes[i].type === 'box' || nodes[i].type === 'penalty' && nodes[i].penalty === -linebreak.infinity && i > breakPointIndex) {\n        break;\n      }\n    }\n\n    return result;\n  } // The main loop of the algorithm\n  // eslint-disable-next-line no-shadow\n\n\n  function mainLoop(node, index, nodes) {\n    var active = activeNodes.first();\n    var next = null;\n    var ratio = 0;\n    var demerits = 0;\n    var candidates = [];\n    var badness;\n    var currentLine = 0;\n    var tmpSum;\n    var currentClass = 0;\n    var fitnessClass;\n    var candidate;\n    var newNode; // The inner loop iterates through all the active nodes with line < currentLine and then\n    // breaks out to insert the new active node candidates before looking at the next active\n    // nodes for the next lines. The result of this is that the active node list is always\n    // sorted by line number.\n\n    while (active !== null) {\n      candidates = [{\n        demerits: Infinity\n      }, {\n        demerits: Infinity\n      }, {\n        demerits: Infinity\n      }, {\n        demerits: Infinity\n      }]; // Iterate through the linked list of active nodes to find new potential active nodes\n      // and deactivate current active nodes.\n\n      while (active !== null) {\n        next = active.next;\n        currentLine = active.data.line + 1;\n        ratio = computeCost(active.data.position, index, active.data, currentLine); // Deactive nodes when the distance between the current active node and the\n        // current node becomes too large (i.e. it exceeds the stretch limit and the stretch\n        // ratio becomes negative) or when the current node is a forced break (i.e. the end\n        // of the paragraph when we want to remove all active nodes, but possibly have a final\n        // candidate active node---if the paragraph can be set using the given tolerance value.)\n\n        if (ratio < -1 || node.type === 'penalty' && node.penalty === -linebreak.infinity) {\n          activeNodes.remove(active);\n        } // If the ratio is within the valid range of -1 <= ratio <= tolerance calculate the\n        // total demerits and record a candidate active node.\n\n\n        if (ratio >= -1 && ratio <= options.tolerance) {\n          badness = 100 * Math.pow(Math.abs(ratio), 3); // Positive penalty\n\n          if (node.type === 'penalty' && node.penalty >= 0) {\n            demerits = Math.pow(options.demerits.line + badness, 2) + Math.pow(node.penalty, 2); // Negative penalty but not a forced break\n          } else if (node.type === 'penalty' && node.penalty !== -linebreak.infinity) {\n            demerits = Math.pow(options.demerits.line + badness, 2) - Math.pow(node.penalty, 2); // All other cases\n          } else {\n            demerits = Math.pow(options.demerits.line + badness, 2);\n          }\n\n          if (node.type === 'penalty' && nodes[active.data.position].type === 'penalty') {\n            demerits += options.demerits.flagged * node.flagged * nodes[active.data.position].flagged;\n          } // Calculate the fitness class for this candidate active node.\n\n\n          if (ratio < -0.5) {\n            currentClass = 0;\n          } else if (ratio <= 0.5) {\n            currentClass = 1;\n          } else if (ratio <= 1) {\n            currentClass = 2;\n          } else {\n            currentClass = 3;\n          } // Add a fitness penalty to the demerits if the fitness classes of two adjacent lines\n          // differ too much.\n\n\n          if (Math.abs(currentClass - active.data.fitnessClass) > 1) {\n            demerits += options.demerits.fitness;\n          } // Add the total demerits of the active node to get the total demerits of this candidate node.\n\n\n          demerits += active.data.demerits; // Only store the best candidate for each fitness class\n\n          if (demerits < candidates[currentClass].demerits) {\n            candidates[currentClass] = {\n              active: active,\n              demerits: demerits,\n              ratio: ratio\n            };\n          }\n        }\n\n        active = next; // Stop iterating through active nodes to insert new candidate active nodes in the active list\n        // before moving on to the active nodes for the next line.\n        // TODO: The Knuth and Plass paper suggests a conditional for currentLine < j0. This means paragraphs\n        // with identical line lengths will not be sorted by line number. Find out if that is a desirable outcome.\n        // For now I left this out, as it only adds minimal overhead to the algorithm and keeping the active node\n        // list sorted has a higher priority.\n\n        if (active !== null && active.data.line >= currentLine) {\n          break;\n        }\n      }\n\n      tmpSum = computeSum(index);\n\n      for (fitnessClass = 0; fitnessClass < candidates.length; fitnessClass += 1) {\n        candidate = candidates[fitnessClass];\n\n        if (candidate.demerits < Infinity) {\n          newNode = new LinkedList.Node(breakpoint(index, candidate.demerits, candidate.ratio, candidate.active.data.line + 1, fitnessClass, tmpSum, candidate.active));\n\n          if (active !== null) {\n            activeNodes.insertBefore(active, newNode);\n          } else {\n            activeNodes.push(newNode);\n          }\n        }\n      }\n    }\n  } // Add an active node for the start of the paragraph.\n\n\n  activeNodes.push(new LinkedList.Node(breakpoint(0, 0, 0, 0, 0, undefined, null))); // eslint-disable-next-line no-shadow\n\n  nodes.forEach(function (node, index, nodes) {\n    if (node.type === 'box') {\n      sum.width += node.width;\n    } else if (node.type === 'glue') {\n      if (index > 0 && nodes[index - 1].type === 'box') {\n        mainLoop(node, index, nodes);\n      }\n\n      sum.width += node.width;\n      sum.stretch += node.stretch;\n      sum.shrink += node.shrink;\n    } else if (node.type === 'penalty' && node.penalty !== linebreak.infinity) {\n      mainLoop(node, index, nodes);\n    }\n  });\n\n  if (activeNodes.size() !== 0) {\n    // Find the best active node (the one with the least total demerits.)\n    activeNodes.forEach(function (node) {\n      if (node.data.demerits < tmp.data.demerits) {\n        tmp = node;\n      }\n    });\n\n    while (tmp !== null) {\n      breaks.push({\n        position: tmp.data.position,\n        ratio: tmp.data.ratio\n      });\n      tmp = tmp.data.previous;\n    }\n\n    return breaks.reverse();\n  }\n\n  return [];\n};\n\nlinebreak.infinity = 10000;\n\nlinebreak.glue = function (width, value, stretch, shrink) {\n  return {\n    type: 'glue',\n    value: value,\n    width: width,\n    stretch: stretch,\n    shrink: shrink\n  };\n};\n\nlinebreak.box = function (width, value, hyphenated) {\n  if (hyphenated === void 0) {\n    hyphenated = false;\n  }\n\n  return {\n    type: 'box',\n    width: width,\n    value: value,\n    hyphenated: hyphenated\n  };\n};\n\nlinebreak.penalty = function (width, penalty, flagged) {\n  return {\n    type: 'penalty',\n    width: width,\n    penalty: penalty,\n    flagged: flagged\n  };\n};\n\n/**\n * Add scalar to run\n *\n * @param  {number}  scalar\n * @param  {Object}  run\n * @return {Object} added run\n */\nvar add = function add(n, run) {\n  var start = run.start + n;\n  var end = run.end + n;\n  return Object.assign({}, run, {\n    start: start,\n    end: end\n  });\n};\n\n/**\n * Get run length\n *\n * @param  {Object}  run\n * @return {number} length\n */\nvar length = function length(run) {\n  return run.end - run.start;\n};\n\n/**\n * Concats two runs into one\n *\n * @param  {Object}  first run\n * @param  {Object}  second run\n * @return {Object}  concatenated run\n */\n\nvar concat = function concat(runA, runB) {\n  var end = runA.end + length(runB);\n  var glyphs = (runA.glyphs || []).concat(runB.glyphs || []);\n  var positions = (runA.positions || []).concat(runB.positions || []);\n  var attributes = Object.assign({}, runA.attributes, runB.attributes);\n  var runAIndices = runA.glyphIndices || [];\n  var runALastIndex = last(runAIndices) || 0;\n  var runBIndices = (runB.glyphIndices || []).map(function (i) {\n    return i + runALastIndex + 1;\n  });\n  var glyphIndices = normalize(runAIndices.concat(runBIndices));\n  return Object.assign({}, runA, {\n    end: end,\n    glyphs: glyphs,\n    positions: positions,\n    attributes: attributes,\n    glyphIndices: glyphIndices\n  });\n};\n\n/**\n * Insert glyph to run in the given index\n *\n * @param  {number}  string index\n * @param  {Object}  glyph\n * @param  {Object}  run\n * @return {Object}  run with glyph\n */\n\nvar insertGlyph$1 = function insertGlyph(index, glyph, run) {\n  if (!glyph) return run; // Split resolves ligature splitting in case new glyph breaks some\n\n  var leadingRun = slice$1(0, index, run);\n  var trailingRun = slice$1(index, Infinity, run);\n  return concat(append$1(glyph, leadingRun), trailingRun);\n};\n/**\n * Insert either glyph or code point to run in the given index\n *\n * @param  {number}  string index\n * @param  {Object | number}  glyph | codePoint\n * @param  {Object}  run\n * @return {Object}  run with glyph\n */\n\n\nvar insert = function insert(index, value, run) {\n  var font = getFont(run);\n  var glyph = isNumber(value) ? fromCodePoint(value, font) : value;\n  return insertGlyph$1(index, glyph, run);\n};\n\n/**\n * Get run index at char index\n *\n * @param  {number}  char index\n * @param  {Object}  attributedString\n * @return {number} run index\n */\n\nvar runIndexAt = function runIndexAt(n, string) {\n  return runIndexAt$1(n, string.runs);\n};\n\n/**\n * Insert glyph into attributed string\n *\n * @param {number} index\n * @param {Object} glyph\n * @param {Object} attributed string\n * @return {Object} attributed string with new glyph\n */\n\nvar insertGlyph = function insertGlyph(index, glyph, attributedString) {\n  var runIndex = runIndexAt(index, attributedString); // Add glyph to the end if run index invalid\n\n  if (runIndex === -1) return append(glyph, attributedString);\n  var codePoints = (glyph === null || glyph === void 0 ? void 0 : glyph.codePoints) || [];\n  var string = attributedString.string.slice(0, index) + stringFromCodePoints(codePoints) + attributedString.string.slice(index);\n  var runs = attributedString.runs.map(function (run, i) {\n    if (i === runIndex) return insert(index - run.start, glyph, run);\n    if (i > runIndex) return add(codePoints.length, run);\n    return run;\n  });\n  return Object.assign({}, attributedString, {\n    string: string,\n    runs: runs\n  });\n};\n\n/**\n * Advance width between two string indices\n *\n * @param  {number}  start glyph index\n * @param  {number}  end glyph index\n * @param  {Object}  run\n * @return {Object} advanced width run\n */\n\nvar advanceWidthBetween$1 = function advanceWidthBetween(start, end, run) {\n  var runStart = run.start || 0;\n  var glyphStartIndex = Math.max(0, glyphIndexAt(start - runStart, run));\n  var glyphEndIndex = Math.max(0, glyphIndexAt(end - runStart, run));\n  var positions = (run.positions || []).slice(glyphStartIndex, glyphEndIndex);\n  return advanceWidth$2(positions);\n};\n\n/**\n * Advance width between start and end\n * Does not consider ligature splitting for the moment.\n * Check performance impact on supporting this\n *\n * @param  {number}  start offset\n * @param  {number}  end offset\n * @param  {Object}  attributedString\n * @return {number} advance width\n */\n\nvar advanceWidthBetween = function advanceWidthBetween(start, end, attributedString) {\n  var runs = filter(start, end, attributedString.runs);\n  return runs.reduce(function (acc, run) {\n    return acc + advanceWidthBetween$1(start, end, run);\n  }, 0);\n};\n\nvar HYPHEN = 0x002d;\nvar TOLERANCE_STEPS = 5;\nvar TOLERANCE_LIMIT = 50;\nvar opts = {\n  width: 3,\n  stretch: 6,\n  shrink: 9\n};\n/**\n * Slice attributed string to many lines\n *\n * @param {Object} attributed string\n * @param  {Array}  nodes\n * @param  {Array}  breaks\n * @return {Array} attributed strings\n */\n\nvar breakLines = function breakLines(string, nodes, breaks) {\n  var start = 0;\n  var end = null;\n  var lines = breaks.reduce(function (acc, breakPoint) {\n    var node = nodes[breakPoint.position];\n    var prevNode = nodes[breakPoint.position - 1]; // Last breakpoint corresponds to K&P mandatory final glue\n\n    if (breakPoint.position === nodes.length - 1) return acc;\n    var line;\n\n    if (node.type === 'penalty') {\n      end = prevNode.value.end;\n      line = slice(start, end, string);\n      line = insertGlyph(line.length, HYPHEN, line);\n    } else {\n      end = node.value.end;\n      line = slice(start, end, string);\n    }\n\n    start = end;\n    return [].concat(acc, [line]);\n  }, []); // Last line\n\n  lines.push(slice(start, string.string.length, string));\n  return lines;\n};\n/**\n * Return Knuth & Plass nodes based on line and previously calculated syllables\n *\n * @param {Object} attributed string\n * @param  {Object}  attributed string\n * @param  {Object}  layout options\n * @return {Array} attributed strings\n */\n\n\nvar getNodes = function getNodes(attributedString, _ref, options) {\n  var align = _ref.align;\n  var start = 0;\n  var hyphenWidth = 5;\n  var syllables = attributedString.syllables;\n  var hyphenPenalty = options.hyphenationPenalty || (align === 'justify' ? 100 : 600);\n  var result = syllables.reduce(function (acc, s, index) {\n    var width = advanceWidthBetween(start, start + s.length, attributedString);\n\n    if (s.trim() === '') {\n      var stretch = width * opts.width / opts.stretch;\n      var shrink = width * opts.width / opts.shrink;\n      var value = {\n        start: start,\n        end: start + s.length\n      };\n      acc.push(linebreak.glue(width, value, stretch, shrink));\n    } else {\n      var hyphenated = syllables[index + 1] !== ' ';\n      var _value = {\n        start: start,\n        end: start + s.length\n      };\n      acc.push(linebreak.box(width, _value, hyphenated));\n\n      if (syllables[index + 1] && hyphenated) {\n        acc.push(linebreak.penalty(hyphenWidth, hyphenPenalty, 1));\n      }\n    }\n\n    start += s.length;\n    return acc;\n  }, []);\n  result.push(linebreak.glue(0, null, linebreak.infinity, 0));\n  result.push(linebreak.penalty(0, -linebreak.infinity, 1));\n  return result;\n};\n\nvar getStyles = function getStyles(attributedString) {\n  var _attributedString$run, _attributedString$run2;\n\n  return ((_attributedString$run = attributedString.runs) === null || _attributedString$run === void 0 ? void 0 : (_attributedString$run2 = _attributedString$run[0]) === null || _attributedString$run2 === void 0 ? void 0 : _attributedString$run2.attributes) || {};\n};\n/**\n * Performs Knuth & Plass line breaking algorithm\n * Fallbacks to best fit algorithm if latter not successful\n *\n * @param  {Object}  layout options\n * @param  {Object}  attributed string\n * @param {Object} attributed string\n * @return {Array} attributed strings\n */\n\n\nvar linebreaker = function linebreaker(options) {\n  return function (attributedString, availableWidths) {\n    var tolerance = options.tolerance || 4;\n    var style = getStyles(attributedString);\n    var nodes = getNodes(attributedString, style, options);\n    var breaks = linebreak(nodes, availableWidths, {\n      tolerance: tolerance\n    }); // Try again with a higher tolerance if the line breaking failed.\n\n    while (breaks.length === 0 && tolerance < TOLERANCE_LIMIT) {\n      tolerance += TOLERANCE_STEPS;\n      breaks = linebreak(nodes, availableWidths, {\n        tolerance: tolerance\n      });\n    }\n\n    if (breaks.length === 0 || breaks.length === 1 && breaks[0].position === 0) {\n      breaks = applyBestFit(nodes, availableWidths);\n    }\n\n    return breakLines(attributedString, nodes, breaks.slice(1));\n  };\n};\n\nvar WHITESPACE_PRIORITY = 1;\nvar LETTER_PRIORITY = 2;\nvar EXPAND_WHITESPACE_FACTOR = {\n  before: 0.5,\n  after: 0.5,\n  priority: WHITESPACE_PRIORITY,\n  unconstrained: false\n};\nvar EXPAND_CHAR_FACTOR = {\n  before: 0.14453125,\n  // 37/256\n  after: 0.14453125,\n  priority: LETTER_PRIORITY,\n  unconstrained: false\n};\nvar SHRINK_WHITESPACE_FACTOR = {\n  before: -0.04296875,\n  // -11/256\n  after: -0.04296875,\n  priority: WHITESPACE_PRIORITY,\n  unconstrained: false\n};\nvar SHRINK_CHAR_FACTOR = {\n  before: -0.04296875,\n  after: -0.04296875,\n  priority: LETTER_PRIORITY,\n  unconstrained: false\n};\n\nvar getCharFactor = function getCharFactor(direction, options) {\n  var expandCharFactor = options.expandCharFactor || {};\n  var shrinkCharFactor = options.shrinkCharFactor || {};\n  return direction === 'GROW' ? Object.assign({}, EXPAND_CHAR_FACTOR, expandCharFactor) : Object.assign({}, SHRINK_CHAR_FACTOR, shrinkCharFactor);\n};\n\nvar getWhitespaceFactor = function getWhitespaceFactor(direction, options) {\n  var expandWhitespaceFactor = options.expandWhitespaceFactor || {};\n  var shrinkWhitespaceFactor = options.shrinkWhitespaceFactor || {};\n  return direction === 'GROW' ? Object.assign({}, EXPAND_WHITESPACE_FACTOR, expandWhitespaceFactor) : Object.assign({}, SHRINK_WHITESPACE_FACTOR, shrinkWhitespaceFactor);\n};\n\nvar factor = function factor(direction, options) {\n  return function (glyphs) {\n    var charFactor = getCharFactor(direction, options);\n    var whitespaceFactor = getWhitespaceFactor(direction, options);\n    var factors = [];\n\n    for (var index = 0; index < glyphs.length; index += 1) {\n      var f = void 0;\n      var glyph = glyphs[index];\n\n      if (isWhiteSpace(glyph)) {\n        f = Object.assign({}, whitespaceFactor);\n\n        if (index === glyphs.length - 1) {\n          f.before = 0;\n\n          if (index > 0) {\n            factors[index - 1].after = 0;\n          }\n        }\n      } else if (glyph.isMark && index > 0) {\n        f = Object.assign({}, factors[index - 1]);\n        f.before = 0;\n        factors[index - 1].after = 0;\n      } else {\n        f = Object.assign({}, charFactor);\n      }\n\n      factors.push(f);\n    }\n\n    return factors;\n  };\n};\n\nvar getFactors = function getFactors(gap, line, options) {\n  var direction = gap > 0 ? 'GROW' : 'SHRINK';\n  var getFactor = factor(direction, options);\n  var factors = line.runs.reduce(function (acc, run) {\n    return acc.concat(getFactor(run.glyphs));\n  }, []);\n  factors[0].before = 0;\n  factors[factors.length - 1].after = 0;\n  return factors;\n};\n\n/* eslint-disable no-multi-assign */\nvar KASHIDA_PRIORITY = 0;\nvar NULL_PRIORITY = 3;\n\nvar getDistances = function getDistances(gap, factors) {\n  var total = 0;\n  var priorities = [];\n  var unconstrained = [];\n\n  for (var _priority = KASHIDA_PRIORITY; _priority <= NULL_PRIORITY; _priority += 1) {\n    priorities[_priority] = unconstrained[_priority] = 0;\n  } // sum the factors at each priority\n\n\n  for (var j = 0; j < factors.length; j += 1) {\n    var f = factors[j];\n    var sum = f.before + f.after;\n    total += sum;\n    priorities[f.priority] += sum;\n\n    if (f.unconstrained) {\n      unconstrained[f.priority] += sum;\n    }\n  } // choose the priorities that need to be applied\n\n\n  var highestPriority = -1;\n  var highestPrioritySum = 0;\n  var remainingGap = gap;\n  var priority;\n\n  for (priority = KASHIDA_PRIORITY; priority <= NULL_PRIORITY; priority += 1) {\n    var prioritySum = priorities[priority];\n\n    if (prioritySum !== 0) {\n      if (highestPriority === -1) {\n        highestPriority = priority;\n        highestPrioritySum = prioritySum;\n      } // if this priority covers the remaining gap, we're done\n\n\n      if (Math.abs(remainingGap) <= Math.abs(prioritySum)) {\n        priorities[priority] = remainingGap / prioritySum;\n        unconstrained[priority] = 0;\n        remainingGap = 0;\n        break;\n      } // mark that we need to use 100% of the adjustment from\n      // this priority, and subtract the space that it consumes\n\n\n      priorities[priority] = 1;\n      remainingGap -= prioritySum; // if this priority has unconstrained glyphs, let them consume the remaining space\n\n      if (unconstrained[priority] !== 0) {\n        unconstrained[priority] = remainingGap / unconstrained[priority];\n        remainingGap = 0;\n        break;\n      }\n    }\n  } // zero out remaining priorities (if any)\n\n\n  for (var p = priority + 1; p <= NULL_PRIORITY; p += 1) {\n    priorities[p] = 0;\n    unconstrained[p] = 0;\n  } // if there is still space left over, assign it to the highest priority that we saw.\n  // this violates their factors, but it only happens in extreme cases\n\n\n  if (remainingGap > 0 && highestPriority > -1) {\n    priorities[highestPriority] = (highestPrioritySum + (gap - total)) / highestPrioritySum;\n  } // create and return an array of distances to add to each glyph's advance\n\n\n  var distances = [];\n\n  for (var index = 0; index < factors.length; index += 1) {\n    // the distance to add to this glyph is the sum of the space to add\n    // after this glyph, and the space to add before the next glyph\n    var _f = factors[index];\n    var next = factors[index + 1];\n    var dist = _f.after * priorities[_f.priority];\n\n    if (next) {\n      dist += next.before * priorities[next.priority];\n    } // if this glyph is unconstrained, add the unconstrained distance as well\n\n\n    if (_f.unconstrained) {\n      dist += _f.after * unconstrained[_f.priority];\n\n      if (next) {\n        dist += next.before * unconstrained[next.priority];\n      }\n    }\n\n    distances.push(dist);\n  }\n\n  return distances;\n};\n\n/**\n * Adjust run positions by given distances\n *\n * @param {Array} distances\n * @param {Object} line\n * @returns {Object} line\n */\n\nvar justifyLine = function justifyLine(distances, line) {\n  var index = 0;\n\n  for (var _iterator = _createForOfIteratorHelperLoose(line.runs), _step; !(_step = _iterator()).done;) {\n    var run = _step.value;\n\n    for (var _iterator2 = _createForOfIteratorHelperLoose(run.positions), _step2; !(_step2 = _iterator2()).done;) {\n      var position = _step2.value;\n      position.xAdvance += distances[index++];\n    }\n  }\n\n  return line;\n};\n/**\n * A JustificationEngine is used by a Typesetter to perform line fragment\n * justification. This implementation is based on a description of Apple's\n * justification algorithm from a PDF in the Apple Font Tools package.\n *\n * //TODO: Make it immutable\n *\n * @param {Object} layout options\n * @param {Object} line\n * @returns {Object} line\n */\n\n\nvar justification = function justification(options) {\n  return function (line) {\n    var gap = line.box.width - advanceWidth(line);\n    if (gap === 0) return; // Exact fit\n\n    var factors = getFactors(gap, line, options);\n    var distances = getDistances(gap, factors);\n    return justifyLine(distances, line);\n  };\n};\n\n/**\n * Returns attributed string ascent\n *\n * @param {Object} attributed string\n * @return {number} ascent\n */\n\nvar ascent = function ascent(attributeString) {\n  var reducer = function reducer(acc, run) {\n    return Math.max(acc, ascent$1(run));\n  };\n\n  return attributeString.runs.reduce(reducer, 0);\n};\n\n/* eslint-disable no-param-reassign */\n\nvar BASE_FONT_SIZE = 12;\n/**\n * A TextDecorationEngine is used by a Typesetter to generate\n * DecorationLines for a line fragment, including underlines\n * and strikes.\n */\n\nvar textDecoration = function textDecoration() {\n  return function (lineFragment) {\n    var x = lineFragment.overflowLeft || 0;\n    var overflowRight = lineFragment.overflowRight || 0;\n    var maxX = advanceWidth(lineFragment) - overflowRight;\n    lineFragment.decorationLines = [];\n\n    for (var i = 0; i < lineFragment.runs.length; i += 1) {\n      var run = lineFragment.runs[i];\n      var width = Math.min(maxX - x, advanceWidth$1(run));\n      var thickness = Math.max(0.5, Math.floor(run.attributes.fontSize / BASE_FONT_SIZE));\n\n      if (run.attributes.underline) {\n        var rect = {\n          x: x,\n          y: ascent(lineFragment) + thickness * 2,\n          width: width,\n          height: thickness\n        };\n        var line = {\n          rect: rect,\n          opacity: run.attributes.opacity,\n          color: run.attributes.underlineColor || 'black',\n          style: run.attributes.underlineStyle || 'solid'\n        };\n        lineFragment.decorationLines.push(line);\n      }\n\n      if (run.attributes.strike) {\n        var y = ascent(lineFragment) - ascent$1(run) / 3;\n        var _rect = {\n          x: x,\n          y: y,\n          width: width,\n          height: thickness\n        };\n        var _line = {\n          rect: _rect,\n          opacity: run.attributes.opacity,\n          color: run.attributes.strikeColor || 'black',\n          style: run.attributes.strikeStyle || 'solid'\n        };\n        lineFragment.decorationLines.push(_line);\n      }\n\n      x += width;\n    }\n\n    return lineFragment;\n  };\n};\n\nvar ignoredScripts = ['Common', 'Inherited', 'Unknown'];\n/**\n * Resolves unicode script in runs, grouping equal runs together\n *\n * @param  {Object}  layout options\n * @param  {Object}  attributed string\n * @return {Object} attributed string\n */\n\nvar scriptItemizer = function scriptItemizer() {\n  return function (attributedString) {\n    var string = attributedString.string;\n    var lastScript = 'Unknown';\n    var lastIndex = 0;\n    var index = 0;\n    var res = [];\n    if (!string) return empty();\n\n    for (var i = 0; i < string.length; i += 1) {\n      var char = string[i];\n      var codePoint = char.codePointAt();\n      var script = unicode.getScript(codePoint);\n\n      if (script !== lastScript && !ignoredScripts.includes(script)) {\n        if (lastScript !== 'Unknown') {\n          res.push({\n            start: lastIndex,\n            end: index,\n            attributes: {\n              script: lastScript\n            }\n          });\n        }\n\n        lastIndex = index;\n        lastScript = script;\n      }\n\n      index += char.length;\n    }\n\n    if (lastIndex < string.length) {\n      res.push({\n        start: lastIndex,\n        end: string.length,\n        attributes: {\n          script: lastScript\n        }\n      });\n    }\n\n    return {\n      string: string,\n      runs: res\n    };\n  };\n};\n\nvar SOFT_HYPHEN = \"\\xAD\";\nvar hyphenator = hyphen(pattern);\n\nvar splitHyphen = function splitHyphen(word) {\n  return word.split(SOFT_HYPHEN);\n};\n\nvar cache = {};\n\nvar getParts = function getParts(word) {\n  var base = word.includes(SOFT_HYPHEN) ? word : hyphenator(word);\n  return splitHyphen(base);\n};\n\nvar wordHyphenation = function wordHyphenation() {\n  return function (word) {\n    var cacheKey = \"_\" + word;\n    if (isNil(word)) return [];\n    if (cache[cacheKey]) return cache[cacheKey];\n    cache[cacheKey] = getParts(word);\n    return cache[cacheKey];\n  };\n};\n\nvar getFontSize = function getFontSize(value) {\n  return value.attributes.fontSize || 12;\n};\n/**\n * Resolve font runs in an AttributedString, grouping equal\n * runs and performing font substitution where necessary.\n *\n * @param  {Object}  layout options\n * @param  {Object}  attributed string\n * @return {Object} attributed string\n */\n\n\nvar fontSubstitution = function fontSubstitution() {\n  return function (attributedString) {\n    var string = attributedString.string,\n        runs = attributedString.runs;\n    var lastFont = null;\n    var lastIndex = 0;\n    var index = 0;\n    var res = [];\n    if (!string) return empty();\n\n    for (var _iterator = _createForOfIteratorHelperLoose(runs), _step; !(_step = _iterator()).done;) {\n      var run = _step.value;\n\n      var _fontSize = getFontSize(run);\n\n      var defaultFont = run.attributes.font;\n\n      if (string.length === 0) {\n        res.push({\n          start: 0,\n          end: 0,\n          attributes: {\n            font: defaultFont\n          }\n        });\n        break;\n      }\n\n      for (var _iterator2 = _createForOfIteratorHelperLoose(string.slice(run.start, run.end)), _step2; !(_step2 = _iterator2()).done;) {\n        var char = _step2.value;\n        var font = defaultFont;\n\n        if (font !== lastFont) {\n          if (lastFont) {\n            res.push({\n              start: lastIndex,\n              end: index,\n              attributes: {\n                font: lastFont,\n                scale: lastFont ? _fontSize / lastFont.unitsPerEm : 0\n              }\n            });\n          }\n\n          lastFont = font;\n          lastIndex = index;\n        }\n\n        index += char.length;\n      }\n    }\n\n    if (lastIndex < string.length) {\n      var fontSize = getFontSize(last(runs));\n      res.push({\n        start: lastIndex,\n        end: string.length,\n        attributes: {\n          font: lastFont,\n          scale: lastFont ? fontSize / lastFont.unitsPerEm : 0\n        }\n      });\n    }\n\n    return {\n      string: string,\n      runs: res\n    };\n  };\n};\n\nexport { layoutEngine as default, fontSubstitution, justification, linebreaker, scriptItemizer, textDecoration, wordHyphenation };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}